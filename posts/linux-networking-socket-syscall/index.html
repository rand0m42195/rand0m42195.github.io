<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Linux 网络编程——socket 系统调用实现剖析 | rand0m's blog</title><meta name=keywords content="Networking,Linux,Socket,C,Rust,Go"><meta name=description content="Linux 下多语言网络编程对比
还记得Linux网络编程姿势吗？如果不记得了，这里有一个用C语言写的tcp_echo服务，用这段代码能帮我们回忆Linux的网络编程套路：

调用socket创建一个网络套接字socket；
调用bind给socket绑定地址；
listen设置
调用accept接收网络请求；

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>

int main(void) {
    int sd = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in addr = {
        .sin_family = AF_INET,
        .sin_port = htons(12345),
        .sin_addr.s_addr = INADDR_ANY,
    };

    bind(sd, (struct sockaddr*)&amp;addr, sizeof(addr));
    listen(sd, 5);

    while (1) {
        int client = accept(sd, NULL, NULL);
        char buf[1024];
        ssize_t n;
        while ((n = recv(client, buf, sizeof(buf), 0)) > 0) {
            send(client, buf, n, 0); // 把读到的内容发送回去
        }
        close(client);
    }

    close(sd);
    return 0;
}
如果你用的是Go、Python、Rust等高级编程语言，可能会对这段代码嗤之以鼻，这么简单一个功能，要创建一个可以通信的TCP连接完全不必这么复杂。
这是用Go写的，如果不考虑错误处理，只需要调用Listen和Accept。"><meta name=author content="rand0m"><link rel=canonical href=https://rand0m42195.github.io/posts/linux-networking-socket-syscall/><link crossorigin=anonymous href=/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://rand0m42195.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://rand0m42195.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://rand0m42195.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://rand0m42195.github.io/apple-touch-icon.png><link rel=mask-icon href=https://rand0m42195.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://rand0m42195.github.io/posts/linux-networking-socket-syscall/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://rand0m42195.github.io/posts/linux-networking-socket-syscall/"><meta property="og:site_name" content="rand0m's blog"><meta property="og:title" content="Linux 网络编程——socket 系统调用实现剖析"><meta property="og:description" content="Linux 下多语言网络编程对比 还记得Linux网络编程姿势吗？如果不记得了，这里有一个用C语言写的tcp_echo服务，用这段代码能帮我们回忆Linux的网络编程套路：
调用socket创建一个网络套接字socket； 调用bind给socket绑定地址； listen设置 调用accept接收网络请求； #include <stdio.h> #include <stdlib.h> #include <string.h> #include <unistd.h> #include <arpa/inet.h> #include <sys/socket.h> int main(void) { int sd = socket(AF_INET, SOCK_STREAM, 0); struct sockaddr_in addr = { .sin_family = AF_INET, .sin_port = htons(12345), .sin_addr.s_addr = INADDR_ANY, }; bind(sd, (struct sockaddr*)&amp;addr, sizeof(addr)); listen(sd, 5); while (1) { int client = accept(sd, NULL, NULL); char buf[1024]; ssize_t n; while ((n = recv(client, buf, sizeof(buf), 0)) > 0) { send(client, buf, n, 0); // 把读到的内容发送回去 } close(client); } close(sd); return 0; } 如果你用的是Go、Python、Rust等高级编程语言，可能会对这段代码嗤之以鼻，这么简单一个功能，要创建一个可以通信的TCP连接完全不必这么复杂。
这是用Go写的，如果不考虑错误处理，只需要调用Listen和Accept。"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-09-24T15:06:05+08:00"><meta property="article:modified_time" content="2025-09-24T15:06:05+08:00"><meta property="article:tag" content="Networking"><meta property="article:tag" content="Linux"><meta property="article:tag" content="Socket"><meta property="article:tag" content="C"><meta property="article:tag" content="Rust"><meta property="article:tag" content="Go"><meta name=twitter:card content="summary"><meta name=twitter:title content="Linux 网络编程——socket 系统调用实现剖析"><meta name=twitter:description content="Linux 下多语言网络编程对比
还记得Linux网络编程姿势吗？如果不记得了，这里有一个用C语言写的tcp_echo服务，用这段代码能帮我们回忆Linux的网络编程套路：

调用socket创建一个网络套接字socket；
调用bind给socket绑定地址；
listen设置
调用accept接收网络请求；

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>

int main(void) {
    int sd = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in addr = {
        .sin_family = AF_INET,
        .sin_port = htons(12345),
        .sin_addr.s_addr = INADDR_ANY,
    };

    bind(sd, (struct sockaddr*)&amp;addr, sizeof(addr));
    listen(sd, 5);

    while (1) {
        int client = accept(sd, NULL, NULL);
        char buf[1024];
        ssize_t n;
        while ((n = recv(client, buf, sizeof(buf), 0)) > 0) {
            send(client, buf, n, 0); // 把读到的内容发送回去
        }
        close(client);
    }

    close(sd);
    return 0;
}
如果你用的是Go、Python、Rust等高级编程语言，可能会对这段代码嗤之以鼻，这么简单一个功能，要创建一个可以通信的TCP连接完全不必这么复杂。
这是用Go写的，如果不考虑错误处理，只需要调用Listen和Accept。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://rand0m42195.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Linux 网络编程——socket 系统调用实现剖析","item":"https://rand0m42195.github.io/posts/linux-networking-socket-syscall/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Linux 网络编程——socket 系统调用实现剖析","name":"Linux 网络编程——socket 系统调用实现剖析","description":"Linux 下多语言网络编程对比 还记得Linux网络编程姿势吗？如果不记得了，这里有一个用C语言写的tcp_echo服务，用这段代码能帮我们回忆Linux的网络编程套路：\n调用socket创建一个网络套接字socket； 调用bind给socket绑定地址； listen设置 调用accept接收网络请求； #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; int main(void) { int sd = socket(AF_INET, SOCK_STREAM, 0); struct sockaddr_in addr = { .sin_family = AF_INET, .sin_port = htons(12345), .sin_addr.s_addr = INADDR_ANY, }; bind(sd, (struct sockaddr*)\u0026amp;addr, sizeof(addr)); listen(sd, 5); while (1) { int client = accept(sd, NULL, NULL); char buf[1024]; ssize_t n; while ((n = recv(client, buf, sizeof(buf), 0)) \u0026gt; 0) { send(client, buf, n, 0); // 把读到的内容发送回去 } close(client); } close(sd); return 0; } 如果你用的是Go、Python、Rust等高级编程语言，可能会对这段代码嗤之以鼻，这么简单一个功能，要创建一个可以通信的TCP连接完全不必这么复杂。\n这是用Go写的，如果不考虑错误处理，只需要调用Listen和Accept。\n","keywords":["Networking","Linux","Socket","C","Rust","Go"],"articleBody":"Linux 下多语言网络编程对比 还记得Linux网络编程姿势吗？如果不记得了，这里有一个用C语言写的tcp_echo服务，用这段代码能帮我们回忆Linux的网络编程套路：\n调用socket创建一个网络套接字socket； 调用bind给socket绑定地址； listen设置 调用accept接收网络请求； #include #include #include #include #include #include int main(void) { int sd = socket(AF_INET, SOCK_STREAM, 0); struct sockaddr_in addr = { .sin_family = AF_INET, .sin_port = htons(12345), .sin_addr.s_addr = INADDR_ANY, }; bind(sd, (struct sockaddr*)\u0026addr, sizeof(addr)); listen(sd, 5); while (1) { int client = accept(sd, NULL, NULL); char buf[1024]; ssize_t n; while ((n = recv(client, buf, sizeof(buf), 0)) \u003e 0) { send(client, buf, n, 0); // 把读到的内容发送回去 } close(client); } close(sd); return 0; } 如果你用的是Go、Python、Rust等高级编程语言，可能会对这段代码嗤之以鼻，这么简单一个功能，要创建一个可以通信的TCP连接完全不必这么复杂。\n这是用Go写的，如果不考虑错误处理，只需要调用Listen和Accept。\npackage main import ( \"io\" \"net\" ) func main() { ln, err := net.Listen(\"tcp\", \"127.0.0.1:12345\") if err != nil { panic(\"listen err\") } for { conn, err := ln.Accept() if err != nil { panic(\"accept error\") } go func(conn net.Conn) { defer conn.Close() io.Copy(conn, conn) }(conn) } } 使用Rust标准库std::net的同步版本如下。\nfn main() { let l = std::net::TcpListener::bind((\"127.0.0.1\", 12345)).unwrap(); for s in l.incoming() { std::thread::spawn(move || { let mut w = s.unwrap(); let mut r = w.try_clone().unwrap(); let _ = std::io::copy(\u0026mut r, \u0026mut w); }); } } 使用Rust标准库tokio::net的异步版本如下。\n#[tokio::main] async fn main() { let l = tokio::net::TcpListener::bind((\"127.0.0.1\", 12345)) .await .unwrap(); loop { let (s, _) = l.accept().await.unwrap(); tokio::spawn(async move { let (mut r, mut w) = s.into_split(); let _ = tokio::io::copy(\u0026mut r, \u0026mut w).await; }); } } 可以看到，使用不同语言进行网络编程，风格差别很大。但是实际不管是C这样古老的编程语言，还是像Go、Rust这样比较现代化的高级编程语言，他们都是对内核提供的网络编程接口进行了封装，本质上底层上是一样的。怎么证明这一结论的正确性呢？可以使用strace来追踪进程的系统调用，看看进程调用了哪些系统调用。\n以下是对上面四段代码编译后使用strace工具追踪的结果：\nC版追踪结果\n可以看到追踪结果和我们在代码中的调用顺序以及传入的参数一致，但实际我们的C代码并不是直接调用了系统调用的socket，而是调用的glibc封装的socket等函数，而这些函数再真正调用socket等系统调用。\nGo版追踪结果\n可以看到Go代码编译后执行过程中也调用了socket、bind、listen、accept等系统调用，而且好多参数都不是我们指定的，看到这里是不是觉得还是C更灵活，因为C可以自由指定系统调用的参数。\nRust std::net版追踪结果\n追踪结果和Go差不多，也是调用了socket、bind、listen、accept，很多参数也都不是我们自己传入的。\nRust tokio::net版追踪结果\n追踪结果和使用std::net实现的版本不太一样，主要是没有看到accept调用，但是多了epool_ctl和futex调用，这也是tokio能支持异步的关键。\n说了这么多，其实就是想证明：不管使用什么语言进行网络编程，最终都是殊途同归。所以要想了解Linux的网络原理，就不得不深入研究这些系统调用都干了啥。接下来我们就一步一步来分析socket系统调用干了啥。\nsocket() 系统调用实现剖析 说明：以下分析使用的Linux内核源码版本为v4.4.302。\nsocket()系统调用的实现在net/socket.c中，socket()中最关键的动作有两步：\n调用sock_create()创建内核socket对象； 调用sock_map_fd()将socket对象映射成fd（用于返回给用户态代码）； SYSCALL_DEFINE3(socket, int, family, int, type, int, protocol) { int retval; struct socket *sock; int flags; /* Check the SOCK_* constants for consistency. */ BUILD_BUG_ON(SOCK_CLOEXEC != O_CLOEXEC); BUILD_BUG_ON((SOCK_MAX | SOCK_TYPE_MASK) != SOCK_TYPE_MASK); BUILD_BUG_ON(SOCK_CLOEXEC \u0026 SOCK_TYPE_MASK); BUILD_BUG_ON(SOCK_NONBLOCK \u0026 SOCK_TYPE_MASK); // 检查、处理参数 flags = type \u0026 ~SOCK_TYPE_MASK; if (flags \u0026 ~(SOCK_CLOEXEC | SOCK_NONBLOCK)) return -EINVAL; type \u0026= SOCK_TYPE_MASK; if (SOCK_NONBLOCK != O_NONBLOCK \u0026\u0026 (flags \u0026 SOCK_NONBLOCK)) flags = (flags \u0026 ~SOCK_NONBLOCK) | O_NONBLOCK; // 创建socket对象 retval = sock_create(family, type, protocol, \u0026sock); if (retval \u003c 0) goto out; // 为socket对象分配fd retval = sock_map_fd(sock, flags \u0026 (O_CLOEXEC | O_NONBLOCK)); if (retval \u003c 0) goto out_release; out: /* It may be already another descriptor 8) Not kernel problem. */ return retval; out_release: sock_release(sock); return retval; } 从socket()系统调用的实现可以看到：socket()把接收的三个参数（family，type，protocol）全都传递给了sock_create()，另外还把保存socket对象地址的指针sock的地址也传进入了，如果sock_create()成功创建了socket对象，它就会把sock指针指向这个对象，只需要给socket()返回一个表示是否出错的整数值即可。\nsock_create分析 下面就看看sock_create()的实现，可以发现sock_create()又加了一个参数，然后调用__sock_create()。这里添加的第一个参数表示当前进程所在的网络命名空间（current指向当前进程task_struct，current-\u003ensproxy-\u003enet_ns就是当前进程所在的网络命名空间），这个可以用来做网络隔离，如docker、ip netns就会用到这个。网络命名空间这个参数不能通过调用方通过参数来指定，而是直接取自当前进程所处的命名空间，所以如果在某个网络命名空间创建socket，需要在调用socket之前先调用setns切换到目标命名空间，在socket返回之后，可以再切换到其他命名空间，此时创建的socket已经和目标socket绑定了，无论进程在哪个网络命名空间，都不会影响socket收发数据包。\nint sock_create(int family, int type, int protocol, struct socket **res) { return __sock_create(current-\u003ensproxy-\u003enet_ns, family, type, protocol, res, 0); } EXPORT_SYMBOL(sock_create); __sock_create()函数比较长，在研究原理的时候，我们把源码中参数检查、安全及返回值检查相关的代码删掉，只留下关键部分，就得到了下面的代码。可以看到主要分为：\n调用sock_alloc()创建一个socket对象； 根据family参数确定具体的协议族； 调用具体的协议族的create()函数； int __sock_create(struct net *net, int family, int type, int protocol, struct socket **res, int kern) { int err; struct socket *sock; const struct net_proto_family *pf; sock = sock_alloc();\t// 创建sock sock-\u003etype = type;\t// type赋值给sock-\u003etype rcu_read_lock(); pf = rcu_dereference(net_families[family]);\t// 根据 family 找到对应的协议族 err = pf-\u003ecreate(net, sock, protocol, kern);\t// 调用目标协议族的create函数 *res = sock; // 把成功创建的sock保存到res中，供调用方使用 return 0; } EXPORT_SYMBOL(__sock_create); 我们调用socket()的时候，传入的family是AF_INET，这个family对应的协议族是什么呢？其实就是inet_family_ops，这是inet_init注册的。从__sock_create()中看到会调用对应协议族的create()函数，对于inet_family_ops而言，create函数就是inet_create()。\nstatic const struct net_proto_family inet_family_ops = { .family = PF_INET,\t// PF_INET 和 AF_INET 相等 .create = inet_create,\t// 使用AF_INET作为family调用socket，最终会执行inet_create函数。 .owner\t= THIS_MODULE, }; static int __init inet_init(void) { (void)sock_register(\u0026inet_family_ops);\t// 注册协议族 // 初始化inetsw列表 /* Register the socket-side information for inet_create. */ for (r = \u0026inetsw[0]; r \u003c \u0026inetsw[SOCK_MAX]; ++r) INIT_LIST_HEAD(r); // 注册protocol(SOCK_STREAM, SOCK_DGRAM、SOCK_RAW) for (q = inetsw_array; q \u003c \u0026inetsw_array[INETSW_ARRAY_LEN]; ++q) inet_register_protosw(q); } 下面就来分析inet_create()干了啥。inet_create()主要逻辑是根据socket()系统调用的第二个参数type和第三个参数protocol来确定具体的传输层（如TCP、UDP、ICMP、RAW）的inet_protosw对象。并创建传输层的sock对象，最终将inet_protosw()的操作和socket对象关联，并将socket对象（struct socket）和传输层sock对象（struct sock）相互绑定。\nstatic int inet_create(struct net *net, struct socket *sock, int protocol, int kern) { struct sock *sk; struct inet_protosw *answer; struct inet_sock *inet; struct proto *answer_prot; unsigned char answer_flags; int try_loading_module = 0; int err; if (protocol \u003c 0 || protocol \u003e= IPPROTO_MAX) return -EINVAL; sock-\u003estate = SS_UNCONNECTED;\t// 初始化socket状态 /* Look for the requested type/protocol pair. */ lookup_protocol: err = -ESOCKTNOSUPPORT; rcu_read_lock(); // 根据sock-\u003etype（socket的第二个参数）遍历sock-\u003etype对应的链表，找到对应的protocol的 // inet_protosw对象 list_for_each_entry_rcu(answer, \u0026inetsw[sock-\u003etype], list) { err = 0; /* Check the non-wild match. */ if (protocol == answer-\u003eprotocol) {\t// 优先精确匹配protocol if (protocol != IPPROTO_IP) break; } else { /* Check for the two wild cases. */ if (IPPROTO_IP == protocol) { protocol = answer-\u003eprotocol; break; } if (IPPROTO_IP == answer-\u003eprotocol) break; } err = -EPROTONOSUPPORT; } sock-\u003eops = answer-\u003eops;\t// 将匹配到的 inet_protosw对象的ops赋值给sock-\u003eops answer_prot = answer-\u003eprot; answer_flags = answer-\u003eflags; // 分配一个sock，注意是sock不是socket！！！ // struct socket是内核套接字对象 // struct sock是传输层的socket状态 sk = sk_alloc(net, PF_INET, GFP_KERNEL, answer_prot, kern);\tinet = inet_sk(sk);\t// 将struct *sock转换成struct *inet_sk，换个视角看待内存 inet-\u003eis_icsk = (INET_PROTOSW_ICSK \u0026 answer_flags) != 0; inet-\u003enodefrag = 0; if (SOCK_RAW == sock-\u003etype) { inet-\u003einet_num = protocol; if (IPPROTO_RAW == protocol) inet-\u003ehdrincl = 1; } // 关联struct socket和struct sock，并出书画struct sock内部某些字段 sock_init_data(sock, sk);\tsk-\u003esk_destruct\t= inet_sock_destruct; sk-\u003esk_protocol\t= protocol; sk-\u003esk_backlog_rcv = sk-\u003esk_prot-\u003ebacklog_rcv; out: return err; } sock_init_data()的作用是对传输层sock对象的成员初始化，如状态（sk_state）、收发缓冲区大小（sk_sndbuf、sk_rcvbuf）等，以及将socket对象和传输层的sock对象相互关联。\nvoid sock_init_data(struct socket *sock, struct sock *sk) { skb_queue_head_init(\u0026sk-\u003esk_receive_queue); skb_queue_head_init(\u0026sk-\u003esk_write_queue); skb_queue_head_init(\u0026sk-\u003esk_error_queue); // 初始化struct sock的一些字段， sk-\u003esk_send_head\t=\tNULL; init_timer(\u0026sk-\u003esk_timer); sk-\u003esk_allocation\t=\tGFP_KERNEL; sk-\u003esk_rcvbuf\t=\tsysctl_rmem_default; sk-\u003esk_sndbuf\t=\tsysctl_wmem_default; sk-\u003esk_state\t=\tTCP_CLOSE; sk_set_socket(sk, sock);\t// sk-\u003esk_socket 指向 sock if (sock) { sk-\u003esk_type\t=\tsock-\u003etype; sk-\u003esk_wq\t=\tsock-\u003ewq; sock-\u003esk\t=\tsk;\t// sock-\u003esk指向sk } else sk-\u003esk_wq\t=\tNULL; // ...... sk-\u003esk_rcvtimeo\t=\tMAX_SCHEDULE_TIMEOUT; sk-\u003esk_sndtimeo\t=\tMAX_SCHEDULE_TIMEOUT; } EXPORT_SYMBOL(sock_init_data); 至此，我们分析完了socket对象的初始化过程。大概思路是：先根据socket()系统调用的第一个参数family找到net_proto_family对象，调用这个对象的create()函数。而net_proto_family的create()函数再根据socket()系统调用的第二、三个参数type和protocol来确定具体的传输层，然后把传输层的一些操作和socket对象关联，另外还创建了一个传输层的sock对象也和socket对象关联起来。至此一个socket对象就算创建并初始化完成。\nsock_map_fd分析 socket()系统调用的本质就是创建一个socket对象，但是内核不能直接把这个内核态的对象返回给用户态。我们知道Linux（或者是Unix）的哲学就是一切皆文件，所以socket()系统调用最终会将内核socket对象以文件描述符的形式传递给用户态，这样还有一个好处，即可以使用read()、write()等通用的文件操作。sock_map_fd函数就是做这个工作的。这个函数的逻辑主要分为三步：\n申请一个新的可用fd； 为struct socket分配一个struct file； 将struct file和申请的fd关联，并最终返回这个fd； static int sock_map_fd(struct socket *sock, int flags) { struct file *newfile; int fd = get_unused_fd_flags(flags);\t// 申请一个可用的fd if (unlikely(fd \u003c 0)) return fd; // 为sock分配一个struct file对象 // struct file的f_op也会被设置为socket专用操作集（socket_file_ops） newfile = sock_alloc_file(sock, flags, NULL);\tif (likely(!IS_ERR(newfile))) { fd_install(fd, newfile);\t// 把刚申请的fd和file对象绑定 return fd; } put_unused_fd(fd); return PTR_ERR(newfile); } 总结 在 Linux 内核中，socket() 系统调用并不是“神秘的黑盒”，而是逐层往下、逐步构建的过程。其核心流程可以总结为：\n参数解析与标志拆分 — 在 syscall 层处理 type 中的 SOCK_CLOEXEC 和 SOCK_NONBLOCK 等标志； sock_create() / __sock_create() — 指定网络命名空间、根据协议族选择 net_proto_family，并调用对应 create 方法； 具体协议族创建 — 比如 AF_INET 的 inet_create()，遍历 inetsw 匹配协议类型（TCP/UDP/RAW），分配 struct sock； 初始化与绑定 — 通过 sock_init_data() 将 struct socket 与 struct sock 关联并初始化各字段； 文件描述符映射 — 通过 sock_map_fd() 分配 fd、创建 struct file、将 file 和 fd 绑定，使用户态可以通过 fd 操作套接字。 通过这一过程，我们能够看到几个关键的设计思想：\n对象-句柄分离：用户态看到的只是一个整数 fd，而真正的 socket 结构体在内核中； 协议层抽象与接口复用：不同协议（TCP/UDP/RAW）共享统一的处理框架，只在 inet_protosw 中区别； 网络命名空间隔离：套接字从一开始就属于某个 struct net，支持容器、namespace 的网络隔离； 掌握了这条按照层级拆解的思路，以后要深入分析更复杂的网络机制（如 connect()、accept()、send()/recv()、中断处理、TCP 状态机等）就更轻松、系统化。\n希望这篇剖析能帮助你揭开socket()系统调用的神秘面纱。\n","wordCount":"907","inLanguage":"zh","datePublished":"2025-09-24T15:06:05+08:00","dateModified":"2025-09-24T15:06:05+08:00","author":{"@type":"Person","name":"rand0m"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://rand0m42195.github.io/posts/linux-networking-socket-syscall/"},"publisher":{"@type":"Organization","name":"rand0m's blog","logo":{"@type":"ImageObject","url":"https://rand0m42195.github.io/favicon.ico"}}}</script><link rel=icon href=/favicon.ico type=image/x-icon><link rel=icon href=/favicon-16x16.png type=image/png size=16x16><link rel=icon href=/favicon-32x32.png type=image/png size=32x32><link rel=icon href=/favicon-192x192.png type=image/png size=192x192><link rel=icon href=/favicon-512x512.png type=image/png size=512x512></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://rand0m42195.github.io/ accesskey=h title="rand0m's blog (Alt + H)">rand0m's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://rand0m42195.github.io/posts/ title=文章><span>文章</span></a></li><li><a href=https://rand0m42195.github.io/about/ title=关于><span>关于</span></a></li><li><a href=https://github.com/rand0m42195 title=GitHub><span>GitHub</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://rand0m42195.github.io/>主页</a>&nbsp;»&nbsp;<a href=https://rand0m42195.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Linux 网络编程——socket 系统调用实现剖析</h1><div class=post-meta><span title='2025-09-24 15:06:05 +0800 +0800'>九月 24, 2025</span>&nbsp;·&nbsp;5 分钟&nbsp;·&nbsp;rand0m</div></header><div class=post-content><h1 id=linux-下多语言网络编程对比>Linux 下多语言网络编程对比<a hidden class=anchor aria-hidden=true href=#linux-下多语言网络编程对比>#</a></h1><p>还记得Linux网络编程姿势吗？如果不记得了，这里有一个用C语言写的<code>tcp_echo</code>服务，用这段代码能帮我们回忆Linux的网络编程套路：</p><ol><li>调用socket创建一个网络套接字socket；</li><li>调用bind给socket绑定地址；</li><li>listen设置</li><li>调用accept接收网络请求；</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;arpa/inet.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/socket.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>void</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> sd <span style=color:#f92672>=</span> <span style=color:#a6e22e>socket</span>(AF_INET, SOCK_STREAM, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> sockaddr_in addr <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>        .sin_family <span style=color:#f92672>=</span> AF_INET,
</span></span><span style=display:flex><span>        .sin_port <span style=color:#f92672>=</span> <span style=color:#a6e22e>htons</span>(<span style=color:#ae81ff>12345</span>),
</span></span><span style=display:flex><span>        .sin_addr.s_addr <span style=color:#f92672>=</span> INADDR_ANY,
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>bind</span>(sd, (<span style=color:#66d9ef>struct</span> sockaddr<span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>addr, <span style=color:#66d9ef>sizeof</span>(addr));
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>listen</span>(sd, <span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (<span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> client <span style=color:#f92672>=</span> <span style=color:#a6e22e>accept</span>(sd, NULL, NULL);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>char</span> buf[<span style=color:#ae81ff>1024</span>];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>ssize_t</span> n;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> ((n <span style=color:#f92672>=</span> <span style=color:#a6e22e>recv</span>(client, buf, <span style=color:#66d9ef>sizeof</span>(buf), <span style=color:#ae81ff>0</span>)) <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>send</span>(client, buf, n, <span style=color:#ae81ff>0</span>); <span style=color:#75715e>// 把读到的内容发送回去
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>close</span>(client);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>close</span>(sd);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果你用的是Go、Python、Rust等高级编程语言，可能会对这段代码嗤之以鼻，这么简单一个功能，要创建一个可以通信的TCP连接完全不必这么复杂。</p><p>这是用<code>Go</code>写的，如果不考虑错误处理，只需要调用<code>Listen</code>和<code>Accept</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;io&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;net&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>ln</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>net</span>.<span style=color:#a6e22e>Listen</span>(<span style=color:#e6db74>&#34;tcp&#34;</span>, <span style=color:#e6db74>&#34;127.0.0.1:12345&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                panic(<span style=color:#e6db74>&#34;listen err&#34;</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>conn</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ln</span>.<span style=color:#a6e22e>Accept</span>()
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                        panic(<span style=color:#e6db74>&#34;accept error&#34;</span>)
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>conn</span> <span style=color:#a6e22e>net</span>.<span style=color:#a6e22e>Conn</span>) {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>conn</span>.<span style=color:#a6e22e>Close</span>()
</span></span><span style=display:flex><span>                        <span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>Copy</span>(<span style=color:#a6e22e>conn</span>, <span style=color:#a6e22e>conn</span>)
</span></span><span style=display:flex><span>                }(<span style=color:#a6e22e>conn</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>使用<code>Rust</code>标准库<code>std::net</code>的同步版本如下。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> l <span style=color:#f92672>=</span> std::net::TcpListener::bind((<span style=color:#e6db74>&#34;127.0.0.1&#34;</span>, <span style=color:#ae81ff>12345</span>)).unwrap();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> s <span style=color:#66d9ef>in</span> l.incoming() {
</span></span><span style=display:flex><span>        std::thread::spawn(<span style=color:#66d9ef>move</span> <span style=color:#f92672>||</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> w <span style=color:#f92672>=</span> s.unwrap();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> r <span style=color:#f92672>=</span> w.try_clone().unwrap();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> _ <span style=color:#f92672>=</span> std::io::copy(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> r, <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> w);
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>使用<code>Rust</code>标准库<code>tokio::net</code>的异步版本如下。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[tokio::main]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> l <span style=color:#f92672>=</span> tokio::net::TcpListener::bind((<span style=color:#e6db74>&#34;127.0.0.1&#34;</span>, <span style=color:#ae81ff>12345</span>))
</span></span><span style=display:flex><span>        .<span style=color:#66d9ef>await</span>
</span></span><span style=display:flex><span>        .unwrap();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>loop</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> (s, _) <span style=color:#f92672>=</span> l.accept().<span style=color:#66d9ef>await</span>.unwrap();
</span></span><span style=display:flex><span>        tokio::spawn(<span style=color:#66d9ef>async</span> <span style=color:#66d9ef>move</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> (<span style=color:#66d9ef>mut</span> r, <span style=color:#66d9ef>mut</span> w) <span style=color:#f92672>=</span> s.into_split();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> _ <span style=color:#f92672>=</span> tokio::io::copy(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> r, <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> w).<span style=color:#66d9ef>await</span>;
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>可以看到，使用不同语言进行网络编程，风格差别很大。但是实际不管是C这样古老的编程语言，还是像Go、Rust这样比较现代化的高级编程语言，他们都是对内核提供的网络编程接口进行了封装，本质上底层上是一样的。怎么证明这一结论的正确性呢？可以使用<code>strace</code>来追踪进程的系统调用，看看进程调用了哪些系统调用。</p><p>以下是对上面四段代码编译后使用strace工具追踪的结果：</p><p><strong>C版追踪结果</strong></p><p><img alt=echo_c loading=lazy src=/images/posts/linux-networking-socket-syscall/strace_echo_c.png></p><p>可以看到追踪结果和我们在代码中的调用顺序以及传入的参数一致，但实际我们的C代码并不是直接调用了系统调用的socket，而是调用的glibc封装的socket等函数，而这些函数再真正调用socket等系统调用。</p><p><strong>Go版追踪结果</strong></p><p><img alt=echo_c loading=lazy src=/images/posts/linux-networking-socket-syscall/strace_echo_go.png></p><p>可以看到Go代码编译后执行过程中也调用了<code>socket</code>、<code>bind</code>、<code>listen</code>、<code>accept</code>等系统调用，而且好多参数都不是我们指定的，看到这里是不是觉得还是C更灵活，因为C可以自由指定系统调用的参数。</p><p><strong>Rust std::net版追踪结果</strong></p><p><img alt=echo_c loading=lazy src=/images/posts/linux-networking-socket-syscall/strace_echo_rust.png></p><p>追踪结果和Go差不多，也是调用了<code>socket</code>、<code>bind</code>、<code>listen</code>、<code>accept</code>，很多参数也都不是我们自己传入的。</p><p><strong>Rust tokio::net版追踪结果</strong></p><p><img alt=echo_c loading=lazy src=/images/posts/linux-networking-socket-syscall/strace_echo_rust_async.png></p><p>追踪结果和使用<code>std::net</code>实现的版本不太一样，主要是没有看到<code>accept</code>调用，但是多了<code>epool_ctl</code>和<code>futex</code>调用，这也是tokio能支持异步的关键。</p><p>说了这么多，其实就是想证明：不管使用什么语言进行网络编程，最终都是殊途同归。所以要想了解Linux的网络原理，就不得不深入研究这些系统调用都干了啥。接下来我们就一步一步来分析<code>socket</code>系统调用干了啥。</p><h2 id=socket-系统调用实现剖析><code>socket()</code> 系统调用实现剖析<a hidden class=anchor aria-hidden=true href=#socket-系统调用实现剖析>#</a></h2><p><strong>说明</strong>：以下分析使用的Linux内核源码版本为<a href=https://elixir.bootlin.com/linux/v4.4.302/source/>v4.4.302</a>。</p><p><code>socket()</code>系统调用的实现在<a href=https://elixir.bootlin.com/linux/v4.4.302/source/net/socket.c#L1202>net/socket.c</a>中，<code>socket()</code>中最关键的动作有两步：</p><ul><li>调用<code>sock_create()</code>创建内核<em>socket对象</em>；</li><li>调用<code>sock_map_fd()</code>将<em>socket对象</em>映射成fd（用于返回给用户态代码）；</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#a6e22e>SYSCALL_DEFINE3</span>(socket, <span style=color:#66d9ef>int</span>, family, <span style=color:#66d9ef>int</span>, type, <span style=color:#66d9ef>int</span>, protocol)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> retval;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>struct</span> socket <span style=color:#f92672>*</span>sock;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> flags;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>/* Check the SOCK_* constants for consistency.  */</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>BUILD_BUG_ON</span>(SOCK_CLOEXEC <span style=color:#f92672>!=</span> O_CLOEXEC);
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>BUILD_BUG_ON</span>((SOCK_MAX <span style=color:#f92672>|</span> SOCK_TYPE_MASK) <span style=color:#f92672>!=</span> SOCK_TYPE_MASK);
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>BUILD_BUG_ON</span>(SOCK_CLOEXEC <span style=color:#f92672>&amp;</span> SOCK_TYPE_MASK);
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>BUILD_BUG_ON</span>(SOCK_NONBLOCK <span style=color:#f92672>&amp;</span> SOCK_TYPE_MASK);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 检查、处理参数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	flags <span style=color:#f92672>=</span> type <span style=color:#f92672>&amp;</span> <span style=color:#f92672>~</span>SOCK_TYPE_MASK;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (flags <span style=color:#f92672>&amp;</span> <span style=color:#f92672>~</span>(SOCK_CLOEXEC <span style=color:#f92672>|</span> SOCK_NONBLOCK))
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span>EINVAL;
</span></span><span style=display:flex><span>	type <span style=color:#f92672>&amp;=</span> SOCK_TYPE_MASK;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (SOCK_NONBLOCK <span style=color:#f92672>!=</span> O_NONBLOCK <span style=color:#f92672>&amp;&amp;</span> (flags <span style=color:#f92672>&amp;</span> SOCK_NONBLOCK))
</span></span><span style=display:flex><span>		flags <span style=color:#f92672>=</span> (flags <span style=color:#f92672>&amp;</span> <span style=color:#f92672>~</span>SOCK_NONBLOCK) <span style=color:#f92672>|</span> O_NONBLOCK;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 创建socket对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	retval <span style=color:#f92672>=</span> <span style=color:#a6e22e>sock_create</span>(family, type, protocol, <span style=color:#f92672>&amp;</span>sock);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (retval <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>goto</span> out;
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 为socket对象分配fd
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	retval <span style=color:#f92672>=</span> <span style=color:#a6e22e>sock_map_fd</span>(sock, flags <span style=color:#f92672>&amp;</span> (O_CLOEXEC <span style=color:#f92672>|</span> O_NONBLOCK));
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (retval <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>goto</span> out_release;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>out:
</span></span><span style=display:flex><span>	<span style=color:#75715e>/* It may be already another descriptor 8) Not kernel problem. */</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> retval;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>out_release:
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>sock_release</span>(sock);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> retval;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>从<code>socket()</code>系统调用的实现可以看到：<code>socket()</code>把接收的三个参数（<code>family</code>，<code>type</code>，<code>protocol</code>）全都传递给了<code>sock_create()</code>，另外还把保存<em>socket对象</em>地址的指针<code>sock</code>的地址也传进入了，如果<code>sock_create()</code>成功创建了<em>socket对象</em>，它就会把<code>sock</code>指针指向这个对象，只需要给<code>socket()</code>返回一个表示是否出错的整数值即可。</p><h3 id=sock_create分析>sock_create分析<a hidden class=anchor aria-hidden=true href=#sock_create分析>#</a></h3><p>下面就看看<code>sock_create()</code>的<a href=https://elixir.bootlin.com/linux/v4.4.302/source/net/socket.c#L1190>实现</a>，可以发现<code>sock_create()</code>又加了一个参数，然后调用<code>__sock_create()</code>。这里添加的第一个参数表示<strong>当前进程所在的网络命名空间</strong>（<code>current</code>指向当前进程<code>task_struct</code>，<code>current->nsproxy->net_ns</code>就是当前进程所在的网络命名空间），这个可以用来做<em>网络隔离</em>，如<em>docker</em>、<em>ip netns</em>就会用到这个。网络命名空间这个参数<strong>不能</strong>通过调用方通过参数来指定，而是直接取自当前进程所处的命名空间，所以如果在某个网络命名空间创建socket，需要在调用<code>socket</code>之前先调用<code>setns</code>切换到目标命名空间，在socket返回之后，可以再切换到其他命名空间，此时创建的socket已经和目标socket绑定了，无论进程在哪个网络命名空间，都不会影响socket收发数据包。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>sock_create</span>(<span style=color:#66d9ef>int</span> family, <span style=color:#66d9ef>int</span> type, <span style=color:#66d9ef>int</span> protocol, <span style=color:#66d9ef>struct</span> socket <span style=color:#f92672>**</span>res)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>__sock_create</span>(current<span style=color:#f92672>-&gt;</span>nsproxy<span style=color:#f92672>-&gt;</span>net_ns, family, type, protocol, res, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>EXPORT_SYMBOL</span>(sock_create);
</span></span></code></pre></div><p><a href=https://elixir.bootlin.com/linux/v4.4.302/source/net/socket.c#L1077><code>__sock_create()</code></a>函数比较长，在研究原理的时候，我们把源码中参数检查、安全及返回值检查相关的代码删掉，只留下关键部分，就得到了下面的代码。可以看到主要分为：</p><ul><li>调用<code>sock_alloc()</code>创建一个<em>socket对象</em>；</li><li>根据<code>family</code>参数确定具体的协议族；</li><li>调用具体的协议族的<code>create()</code>函数；</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>__sock_create</span>(<span style=color:#66d9ef>struct</span> net <span style=color:#f92672>*</span>net, <span style=color:#66d9ef>int</span> family, <span style=color:#66d9ef>int</span> type, <span style=color:#66d9ef>int</span> protocol,
</span></span><span style=display:flex><span>			 <span style=color:#66d9ef>struct</span> socket <span style=color:#f92672>**</span>res, <span style=color:#66d9ef>int</span> kern)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> err;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>struct</span> socket <span style=color:#f92672>*</span>sock;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>struct</span> net_proto_family <span style=color:#f92672>*</span>pf;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	sock <span style=color:#f92672>=</span> <span style=color:#a6e22e>sock_alloc</span>();	<span style=color:#75715e>// 创建sock
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	
</span></span><span style=display:flex><span>	sock<span style=color:#f92672>-&gt;</span>type <span style=color:#f92672>=</span> type;		<span style=color:#75715e>// type赋值给sock-&gt;type
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>rcu_read_lock</span>();
</span></span><span style=display:flex><span>	pf <span style=color:#f92672>=</span> <span style=color:#a6e22e>rcu_dereference</span>(net_families[family]);		<span style=color:#75715e>// 根据 family 找到对应的协议族
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	
</span></span><span style=display:flex><span>	err <span style=color:#f92672>=</span> pf<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>create</span>(net, sock, protocol, kern);	<span style=color:#75715e>// 调用目标协议族的create函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	
</span></span><span style=display:flex><span>	<span style=color:#f92672>*</span>res <span style=color:#f92672>=</span> sock; 	<span style=color:#75715e>// 把成功创建的sock保存到res中，供调用方使用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>EXPORT_SYMBOL</span>(__sock_create);
</span></span></code></pre></div><p>我们调用<code>socket()</code>的时候，传入的<code>family</code>是<em>AF_INET</em>，这个<code>family</code>对应的协议族是什么呢？其实就是<code>inet_family_ops</code>，这是<a href=https://elixir.bootlin.com/linux/v4.4.302/source/net/ipv4/af_inet.c#L1731><code>inet_init</code></a>注册的。从<code>__sock_create()</code>中看到会调用对应协议族的<code>create()</code>函数，对于<code>inet_family_ops</code>而言，create函数就是<code>inet_create()</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>struct</span> net_proto_family inet_family_ops <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>	.family <span style=color:#f92672>=</span> PF_INET,		<span style=color:#75715e>// PF_INET 和 AF_INET 相等
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	.create <span style=color:#f92672>=</span> inet_create,	<span style=color:#75715e>// 使用AF_INET作为family调用socket，最终会执行inet_create函数。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	.owner	<span style=color:#f92672>=</span> THIS_MODULE,
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> __init <span style=color:#a6e22e>inet_init</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	(<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>sock_register</span>(<span style=color:#f92672>&amp;</span>inet_family_ops);	<span style=color:#75715e>// 注册协议族
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 初始化inetsw列表
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>/* Register the socket-side information for inet_create. */</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> (r <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>inetsw[<span style=color:#ae81ff>0</span>]; r <span style=color:#f92672>&lt;</span> <span style=color:#f92672>&amp;</span>inetsw[SOCK_MAX]; <span style=color:#f92672>++</span>r)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>INIT_LIST_HEAD</span>(r);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 注册protocol(SOCK_STREAM, SOCK_DGRAM、SOCK_RAW)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span> (q <span style=color:#f92672>=</span> inetsw_array; q <span style=color:#f92672>&lt;</span> <span style=color:#f92672>&amp;</span>inetsw_array[INETSW_ARRAY_LEN]; <span style=color:#f92672>++</span>q)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>inet_register_protosw</span>(q);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>下面就来分析<a href=https://elixir.bootlin.com/linux/v4.4.302/source/net/ipv4/af_inet.c#L249><code>inet_create()</code></a>干了啥。<code>inet_create()</code>主要逻辑是根据<code>socket()</code>系统调用的第二个参数<code>type</code>和第三个参数<code>protocol</code>来确定具体的传输层（如TCP、UDP、ICMP、RAW）的<code>inet_protosw</code>对象。并创建<strong>传输层</strong>的<em>sock对象</em>，最终将<code>inet_protosw()</code>的操作和<em>socket对象</em>关联，并将<em>socket对象</em>（struct socket）和传输层<em>sock对象</em>（struct sock）相互绑定。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>inet_create</span>(<span style=color:#66d9ef>struct</span> net <span style=color:#f92672>*</span>net, <span style=color:#66d9ef>struct</span> socket <span style=color:#f92672>*</span>sock, <span style=color:#66d9ef>int</span> protocol,
</span></span><span style=display:flex><span>		       <span style=color:#66d9ef>int</span> kern)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>struct</span> sock <span style=color:#f92672>*</span>sk;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>struct</span> inet_protosw <span style=color:#f92672>*</span>answer;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>struct</span> inet_sock <span style=color:#f92672>*</span>inet;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>struct</span> proto <span style=color:#f92672>*</span>answer_prot;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>char</span> answer_flags;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> try_loading_module <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> err;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (protocol <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> protocol <span style=color:#f92672>&gt;=</span> IPPROTO_MAX)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span>EINVAL;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	sock<span style=color:#f92672>-&gt;</span>state <span style=color:#f92672>=</span> SS_UNCONNECTED;	<span style=color:#75715e>// 初始化socket状态
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>/* Look for the requested type/protocol pair. */</span>
</span></span><span style=display:flex><span>lookup_protocol:
</span></span><span style=display:flex><span>	err <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>ESOCKTNOSUPPORT;
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>rcu_read_lock</span>();
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 根据sock-&gt;type（socket的第二个参数）遍历sock-&gt;type对应的链表，找到对应的protocol的
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// inet_protosw对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>list_for_each_entry_rcu</span>(answer, <span style=color:#f92672>&amp;</span>inetsw[sock<span style=color:#f92672>-&gt;</span>type], list) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		err <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>		<span style=color:#75715e>/* Check the non-wild match. */</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (protocol <span style=color:#f92672>==</span> answer<span style=color:#f92672>-&gt;</span>protocol) {	<span style=color:#75715e>// 优先精确匹配protocol
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#66d9ef>if</span> (protocol <span style=color:#f92672>!=</span> IPPROTO_IP)
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>		} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>			<span style=color:#75715e>/* Check for the two wild cases. */</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> (IPPROTO_IP <span style=color:#f92672>==</span> protocol) {
</span></span><span style=display:flex><span>				protocol <span style=color:#f92672>=</span> answer<span style=color:#f92672>-&gt;</span>protocol;
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> (IPPROTO_IP <span style=color:#f92672>==</span> answer<span style=color:#f92672>-&gt;</span>protocol)
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		err <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>EPROTONOSUPPORT;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	sock<span style=color:#f92672>-&gt;</span>ops <span style=color:#f92672>=</span> answer<span style=color:#f92672>-&gt;</span>ops;		<span style=color:#75715e>// 将匹配到的 inet_protosw对象的ops赋值给sock-&gt;ops
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	answer_prot <span style=color:#f92672>=</span> answer<span style=color:#f92672>-&gt;</span>prot;
</span></span><span style=display:flex><span>	answer_flags <span style=color:#f92672>=</span> answer<span style=color:#f92672>-&gt;</span>flags;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 分配一个sock，注意是sock不是socket！！！
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// struct socket是内核套接字对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// struct sock是传输层的socket状态
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	sk <span style=color:#f92672>=</span> <span style=color:#a6e22e>sk_alloc</span>(net, PF_INET, GFP_KERNEL, answer_prot, kern);	
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	inet <span style=color:#f92672>=</span> <span style=color:#a6e22e>inet_sk</span>(sk);		<span style=color:#75715e>// 将struct *sock转换成struct *inet_sk，换个视角看待内存
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	inet<span style=color:#f92672>-&gt;</span>is_icsk <span style=color:#f92672>=</span> (INET_PROTOSW_ICSK <span style=color:#f92672>&amp;</span> answer_flags) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	inet<span style=color:#f92672>-&gt;</span>nodefrag <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (SOCK_RAW <span style=color:#f92672>==</span> sock<span style=color:#f92672>-&gt;</span>type) {
</span></span><span style=display:flex><span>		inet<span style=color:#f92672>-&gt;</span>inet_num <span style=color:#f92672>=</span> protocol;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (IPPROTO_RAW <span style=color:#f92672>==</span> protocol)
</span></span><span style=display:flex><span>			inet<span style=color:#f92672>-&gt;</span>hdrincl <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 关联struct socket和struct sock，并出书画struct sock内部某些字段
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>sock_init_data</span>(sock, sk);	
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	sk<span style=color:#f92672>-&gt;</span>sk_destruct	   <span style=color:#f92672>=</span> inet_sock_destruct;
</span></span><span style=display:flex><span>	sk<span style=color:#f92672>-&gt;</span>sk_protocol	   <span style=color:#f92672>=</span> protocol;
</span></span><span style=display:flex><span>	sk<span style=color:#f92672>-&gt;</span>sk_backlog_rcv <span style=color:#f92672>=</span> sk<span style=color:#f92672>-&gt;</span>sk_prot<span style=color:#f92672>-&gt;</span>backlog_rcv;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>out:
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> err;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><a href=https://elixir.bootlin.com/linux/v4.4.302/source/net/core/sock.c#L2407><code>sock_init_data()</code></a>的作用是对传输层<em>sock对象</em>的成员初始化，如状态（sk_state）、收发缓冲区大小（sk_sndbuf、sk_rcvbuf）等，以及将<em>socket对象</em>和传输层的<em>sock对象</em>相互关联。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sock_init_data</span>(<span style=color:#66d9ef>struct</span> socket <span style=color:#f92672>*</span>sock, <span style=color:#66d9ef>struct</span> sock <span style=color:#f92672>*</span>sk)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>skb_queue_head_init</span>(<span style=color:#f92672>&amp;</span>sk<span style=color:#f92672>-&gt;</span>sk_receive_queue);
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>skb_queue_head_init</span>(<span style=color:#f92672>&amp;</span>sk<span style=color:#f92672>-&gt;</span>sk_write_queue);
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>skb_queue_head_init</span>(<span style=color:#f92672>&amp;</span>sk<span style=color:#f92672>-&gt;</span>sk_error_queue);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 初始化struct sock的一些字段，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	sk<span style=color:#f92672>-&gt;</span>sk_send_head	<span style=color:#f92672>=</span>	NULL;
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>init_timer</span>(<span style=color:#f92672>&amp;</span>sk<span style=color:#f92672>-&gt;</span>sk_timer);
</span></span><span style=display:flex><span>	sk<span style=color:#f92672>-&gt;</span>sk_allocation	<span style=color:#f92672>=</span>	GFP_KERNEL;
</span></span><span style=display:flex><span>	sk<span style=color:#f92672>-&gt;</span>sk_rcvbuf		<span style=color:#f92672>=</span>	sysctl_rmem_default;
</span></span><span style=display:flex><span>	sk<span style=color:#f92672>-&gt;</span>sk_sndbuf		<span style=color:#f92672>=</span>	sysctl_wmem_default;
</span></span><span style=display:flex><span>	sk<span style=color:#f92672>-&gt;</span>sk_state		<span style=color:#f92672>=</span>	TCP_CLOSE;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>sk_set_socket</span>(sk, sock);	<span style=color:#75715e>// sk-&gt;sk_socket 指向 sock
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (sock) {
</span></span><span style=display:flex><span>		sk<span style=color:#f92672>-&gt;</span>sk_type	<span style=color:#f92672>=</span>	sock<span style=color:#f92672>-&gt;</span>type;
</span></span><span style=display:flex><span>		sk<span style=color:#f92672>-&gt;</span>sk_wq	<span style=color:#f92672>=</span>	sock<span style=color:#f92672>-&gt;</span>wq;
</span></span><span style=display:flex><span>		sock<span style=color:#f92672>-&gt;</span>sk	<span style=color:#f92672>=</span>	sk;			<span style=color:#75715e>// sock-&gt;sk指向sk
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	} <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>		sk<span style=color:#f92672>-&gt;</span>sk_wq	<span style=color:#f92672>=</span>	NULL;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// ......
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	sk<span style=color:#f92672>-&gt;</span>sk_rcvtimeo		<span style=color:#f92672>=</span>	MAX_SCHEDULE_TIMEOUT;
</span></span><span style=display:flex><span>	sk<span style=color:#f92672>-&gt;</span>sk_sndtimeo		<span style=color:#f92672>=</span>	MAX_SCHEDULE_TIMEOUT;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>EXPORT_SYMBOL</span>(sock_init_data);
</span></span></code></pre></div><p>至此，我们分析完了<em>socket对象</em>的初始化过程。大概思路是：先根据<code>socket()</code>系统调用的第一个参数<code>family</code>找到<code>net_proto_family</code>对象，调用这个对象的<code>create()</code>函数。而<code>net_proto_family</code>的<code>create()</code>函数再根据<code>socket()</code>系统调用的第二、三个参数<code>type</code>和<code>protocol</code>来确定具体的传输层，然后把传输层的一些操作和<em>socket对象</em>关联，另外还创建了一个传输层的<em>sock对象</em>也和<em>socket对象</em>关联起来。至此一个<em>socket对象</em>就算创建并初始化完成。</p><h3 id=sock_map_fd分析>sock_map_fd分析<a hidden class=anchor aria-hidden=true href=#sock_map_fd分析>#</a></h3><p><code>socket()</code>系统调用的本质就是创建一个socket对象，但是内核不能直接把这个内核态的对象返回给用户态。我们知道Linux（或者是Unix）的哲学就是<strong>一切皆文件</strong>，所以<code>socket()</code>系统调用最终会将内核socket对象以文件描述符的形式传递给用户态，这样还有一个好处，即可以使用<code>read()</code>、<code>write()</code>等通用的文件操作。<a href=https://elixir.bootlin.com/linux/v4.4.302/source/net/socket.c#L392><code>sock_map_fd</code></a>函数就是做这个工作的。这个函数的逻辑主要分为三步：</p><ul><li>申请一个新的可用fd；</li><li>为struct socket分配一个struct file；</li><li>将struct file和申请的fd关联，并最终返回这个fd；</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>sock_map_fd</span>(<span style=color:#66d9ef>struct</span> socket <span style=color:#f92672>*</span>sock, <span style=color:#66d9ef>int</span> flags)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>struct</span> file <span style=color:#f92672>*</span>newfile;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> fd <span style=color:#f92672>=</span> <span style=color:#a6e22e>get_unused_fd_flags</span>(flags);	<span style=color:#75715e>// 申请一个可用的fd
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>unlikely</span>(fd <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>))
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> fd;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 为sock分配一个struct file对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// struct file的f_op也会被设置为socket专用操作集（socket_file_ops）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	newfile <span style=color:#f92672>=</span> <span style=color:#a6e22e>sock_alloc_file</span>(sock, flags, NULL);	
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>likely</span>(<span style=color:#f92672>!</span><span style=color:#a6e22e>IS_ERR</span>(newfile))) {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fd_install</span>(fd, newfile);	<span style=color:#75715e>// 把刚申请的fd和file对象绑定
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>return</span> fd;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>put_unused_fd</span>(fd);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>PTR_ERR</span>(newfile);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><p>在 Linux 内核中，<code>socket()</code> 系统调用并不是“神秘的黑盒”，而是逐层往下、逐步构建的过程。其核心流程可以总结为：</p><ol><li><strong>参数解析与标志拆分</strong> — 在 syscall 层处理 <code>type</code> 中的 <code>SOCK_CLOEXEC</code> 和 <code>SOCK_NONBLOCK</code> 等标志；</li><li><strong><code>sock_create()</code> / <code>__sock_create()</code></strong> — 指定网络命名空间、根据协议族选择 <code>net_proto_family</code>，并调用对应 <code>create</code> 方法；</li><li><strong>具体协议族创建</strong> — 比如 AF_INET 的 <code>inet_create()</code>，遍历 <code>inetsw</code> 匹配协议类型（TCP/UDP/RAW），分配 <code>struct sock</code>；</li><li><strong>初始化与绑定</strong> — 通过 <code>sock_init_data()</code> 将 <code>struct socket</code> 与 <code>struct sock</code> 关联并初始化各字段；</li><li><strong>文件描述符映射</strong> — 通过 <code>sock_map_fd()</code> 分配 fd、创建 <code>struct file</code>、将 file 和 fd 绑定，使用户态可以通过 fd 操作套接字。</li></ol><p>通过这一过程，我们能够看到几个关键的设计思想：</p><ul><li><strong>对象-句柄分离</strong>：用户态看到的只是一个整数 fd，而真正的 socket 结构体在内核中；</li><li><strong>协议层抽象与接口复用</strong>：不同协议（TCP/UDP/RAW）共享统一的处理框架，只在 <code>inet_protosw</code> 中区别；</li><li><strong>网络命名空间隔离</strong>：套接字从一开始就属于某个 <code>struct net</code>，支持容器、namespace 的网络隔离；</li></ul><p>掌握了这条按照层级拆解的思路，以后要深入分析更复杂的网络机制（如 <code>connect()</code>、<code>accept()</code>、<code>send()</code>/<code>recv()</code>、中断处理、TCP 状态机等）就更轻松、系统化。</p><p>希望这篇剖析能帮助你揭开<code>socket()</code>系统调用的神秘面纱。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://rand0m42195.github.io/tags/networking/>Networking</a></li><li><a href=https://rand0m42195.github.io/tags/linux/>Linux</a></li><li><a href=https://rand0m42195.github.io/tags/socket/>Socket</a></li><li><a href=https://rand0m42195.github.io/tags/c/>C</a></li><li><a href=https://rand0m42195.github.io/tags/rust/>Rust</a></li><li><a href=https://rand0m42195.github.io/tags/go/>Go</a></li></ul><nav class=paginav><a class=prev href=https://rand0m42195.github.io/posts/linux-ebpf-xdp-models/><span class=title>« 上一页</span><br><span>XDP 挂载模式剖析</span>
</a><a class=next href=https://rand0m42195.github.io/posts/linux-networking-receive/><span class=title>下一页 »</span><br><span>网络数据包接受过程分析——从网卡到内核协议栈（以Intel e1000 + Linux 4.4为例）</span></a></nav></footer><div id=comments><script src=https://giscus.app/client.js data-repo=rand0m42195/rand0m42195.github.io data-repo-id=R_kgDOPzDcOw data-category=Announcements data-category-id=DIC_kwDOPzDcO84CvpUm data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=en crossorigin=anonymous async></script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://rand0m42195.github.io/>rand0m's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>