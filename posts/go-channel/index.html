<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Go Channel源码解读 | rand0m's blog</title><meta name=keywords content="Go,Channel,Source"><meta name=description content="
“Don’t communicate by sharing memory, share memory by communicating.”
不要通过共享内存来通信，而要通过通信来共享内存。
channel 介绍
channel是Go语言内置的一个非常重要的feature，相比其他语言，channel为Go提供了goroutine之间通信的独特方式。它和Linux的管道很像，goroutine可以向可写的channel写入数据，也可以从channel中读取数据，还可以关闭channel。这篇文章结合Go的源码来分析channel的实现原理，包括channel的创建、读、写和关闭。
channel实现原理
hchan结构体
Go语言的channel本质上是一个带锁的等待队列的循环缓冲区队列，它的源码在runtime/chan.go中，其实就是一个hchan结构体：
type hchan struct {
	qcount   uint           // total data in the queue
	dataqsiz uint           // size of the circular queue
	buf      unsafe.Pointer // points to an array of dataqsiz elements
	elemsize uint16
	closed   uint32
	timer    *timer // timer feeding this chan
	elemtype *_type // element type
	sendx    uint   // send index
	recvx    uint   // receive index
	recvq    waitq  // list of recv waiters
	sendq    waitq  // list of send waiters

	// lock protects all fields in hchan, as well as several
	// fields in sudogs blocked on this channel.
	//
	// Do not change another G's status while holding this lock
	// (in particular, do not ready a G), as this can deadlock
	// with stack shrinking.
	lock mutex
}
hchan结构体各成员的含义如下："><meta name=author content="rand0m"><link rel=canonical href=https://rand0m42195.github.io/posts/go-channel/><link crossorigin=anonymous href=/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://rand0m42195.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://rand0m42195.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://rand0m42195.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://rand0m42195.github.io/apple-touch-icon.png><link rel=mask-icon href=https://rand0m42195.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://rand0m42195.github.io/posts/go-channel/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://rand0m42195.github.io/posts/go-channel/"><meta property="og:site_name" content="rand0m's blog"><meta property="og:title" content="Go Channel源码解读"><meta property="og:description" content=" “Don’t communicate by sharing memory, share memory by communicating.” 不要通过共享内存来通信，而要通过通信来共享内存。
channel 介绍 channel是Go语言内置的一个非常重要的feature，相比其他语言，channel为Go提供了goroutine之间通信的独特方式。它和Linux的管道很像，goroutine可以向可写的channel写入数据，也可以从channel中读取数据，还可以关闭channel。这篇文章结合Go的源码来分析channel的实现原理，包括channel的创建、读、写和关闭。
channel实现原理 hchan结构体 Go语言的channel本质上是一个带锁的等待队列的循环缓冲区队列，它的源码在runtime/chan.go中，其实就是一个hchan结构体：
type hchan struct { qcount uint // total data in the queue dataqsiz uint // size of the circular queue buf unsafe.Pointer // points to an array of dataqsiz elements elemsize uint16 closed uint32 timer *timer // timer feeding this chan elemtype *_type // element type sendx uint // send index recvx uint // receive index recvq waitq // list of recv waiters sendq waitq // list of send waiters // lock protects all fields in hchan, as well as several // fields in sudogs blocked on this channel. // // Do not change another G's status while holding this lock // (in particular, do not ready a G), as this can deadlock // with stack shrinking. lock mutex } hchan结构体各成员的含义如下："><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-10-14T14:12:34+08:00"><meta property="article:modified_time" content="2025-10-14T14:12:34+08:00"><meta property="article:tag" content="Go"><meta property="article:tag" content="Channel"><meta property="article:tag" content="Source"><meta name=twitter:card content="summary"><meta name=twitter:title content="Go Channel源码解读"><meta name=twitter:description content="
“Don’t communicate by sharing memory, share memory by communicating.”
不要通过共享内存来通信，而要通过通信来共享内存。
channel 介绍
channel是Go语言内置的一个非常重要的feature，相比其他语言，channel为Go提供了goroutine之间通信的独特方式。它和Linux的管道很像，goroutine可以向可写的channel写入数据，也可以从channel中读取数据，还可以关闭channel。这篇文章结合Go的源码来分析channel的实现原理，包括channel的创建、读、写和关闭。
channel实现原理
hchan结构体
Go语言的channel本质上是一个带锁的等待队列的循环缓冲区队列，它的源码在runtime/chan.go中，其实就是一个hchan结构体：
type hchan struct {
	qcount   uint           // total data in the queue
	dataqsiz uint           // size of the circular queue
	buf      unsafe.Pointer // points to an array of dataqsiz elements
	elemsize uint16
	closed   uint32
	timer    *timer // timer feeding this chan
	elemtype *_type // element type
	sendx    uint   // send index
	recvx    uint   // receive index
	recvq    waitq  // list of recv waiters
	sendq    waitq  // list of send waiters

	// lock protects all fields in hchan, as well as several
	// fields in sudogs blocked on this channel.
	//
	// Do not change another G's status while holding this lock
	// (in particular, do not ready a G), as this can deadlock
	// with stack shrinking.
	lock mutex
}
hchan结构体各成员的含义如下："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://rand0m42195.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Go Channel源码解读","item":"https://rand0m42195.github.io/posts/go-channel/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Go Channel源码解读","name":"Go Channel源码解读","description":" “Don’t communicate by sharing memory, share memory by communicating.” 不要通过共享内存来通信，而要通过通信来共享内存。\nchannel 介绍 channel是Go语言内置的一个非常重要的feature，相比其他语言，channel为Go提供了goroutine之间通信的独特方式。它和Linux的管道很像，goroutine可以向可写的channel写入数据，也可以从channel中读取数据，还可以关闭channel。这篇文章结合Go的源码来分析channel的实现原理，包括channel的创建、读、写和关闭。\nchannel实现原理 hchan结构体 Go语言的channel本质上是一个带锁的等待队列的循环缓冲区队列，它的源码在runtime/chan.go中，其实就是一个hchan结构体：\ntype hchan struct { qcount uint // total data in the queue dataqsiz uint // size of the circular queue buf unsafe.Pointer // points to an array of dataqsiz elements elemsize uint16 closed uint32 timer *timer // timer feeding this chan elemtype *_type // element type sendx uint // send index recvx uint // receive index recvq waitq // list of recv waiters sendq waitq // list of send waiters // lock protects all fields in hchan, as well as several // fields in sudogs blocked on this channel. // // Do not change another G\u0026#39;s status while holding this lock // (in particular, do not ready a G), as this can deadlock // with stack shrinking. lock mutex } hchan结构体各成员的含义如下：\n","keywords":["Go","Channel","Source"],"articleBody":" “Don’t communicate by sharing memory, share memory by communicating.” 不要通过共享内存来通信，而要通过通信来共享内存。\nchannel 介绍 channel是Go语言内置的一个非常重要的feature，相比其他语言，channel为Go提供了goroutine之间通信的独特方式。它和Linux的管道很像，goroutine可以向可写的channel写入数据，也可以从channel中读取数据，还可以关闭channel。这篇文章结合Go的源码来分析channel的实现原理，包括channel的创建、读、写和关闭。\nchannel实现原理 hchan结构体 Go语言的channel本质上是一个带锁的等待队列的循环缓冲区队列，它的源码在runtime/chan.go中，其实就是一个hchan结构体：\ntype hchan struct { qcount uint // total data in the queue dataqsiz uint // size of the circular queue buf unsafe.Pointer // points to an array of dataqsiz elements elemsize uint16 closed uint32 timer *timer // timer feeding this chan elemtype *_type // element type sendx uint // send index recvx uint // receive index recvq waitq // list of recv waiters sendq waitq // list of send waiters // lock protects all fields in hchan, as well as several // fields in sudogs blocked on this channel. // // Do not change another G's status while holding this lock // (in particular, do not ready a G), as this can deadlock // with stack shrinking. lock mutex } hchan结构体各成员的含义如下：\nqcount: 循环缓冲区队列当前存放的数据量，qcount = 0 时缓冲区为空，qcount = dataqsiz 时缓冲区满； dataqsiz: 循环缓冲区队列的容量（即make(chan T, N)时指定的**N**）； buf: 指向循环缓冲区队列； elemsize: channel元素大小（注意这里是uint16，所以大小不能超过65535字节）； closed: 标识channel是否已经被关闭； timer: 与channel关联的定时器，主要用于select和超时机制； elemtype: channel元素的类型信息，runtime需要用它来确定elemsize； sendx: 下一个要写入的循环缓冲区索引； recvx: 下一个要读取的循环缓冲区索引； recvq: 正在等待接收数据的goroutine队列，当缓冲区空且者无发送者时，尝试以阻塞方式读取channel的goroutine会被加入此队列； sendq: 正在等待发送数据的goroutine队列，当无接收者且缓冲区已满时，尝试以阻塞方式读取channel的goroutine会被加入此队列； lock: 保护整个hchan中所有成员的锁； 这个结构体相对比较简单，各成员的功能也相对比较好理解，下面就分别介绍channel的创建、写入、读出、关闭的实现。\n创建channel Go语言中，使用channel之前需要先用make创建，有两种方式：\n// 方式一，创建无缓冲的channel make(chan int) // 方式二，创建有缓冲的channel make(chan int, 8) 无论是哪种方式创建的，Go的编译器都是调用runtime.makechan()来创建。从直觉上来看，channel的底层就是一个hchan结构体，创建channel就是创建一个结构体，并根据创建时提供的参数对结构体的相关成员初始化即可。以下是runtime.makechan()的源码，makechan接受两个参数，第一个参数是channel元素类型相关的指针，第二个参数是缓冲区大小，无缓冲则为0。\n在为hchan分配循环缓冲区时，源码考虑了三种情况：\n无缓冲 或 缓冲区大小为0，这种情况不需要分配缓冲区，所以只创建一个hchan本体即可； 有缓冲区，但是元素的类型不是指针，这种情况把数据写入channel时，只需要将要写的数据拷贝一份到循环缓冲区即可，所以就把hchan本体和缓冲区放在一起，申请一整块内存，并让buf指向hchan结束的位置即可； 有缓冲，且元素类型是指针，这种情况就需要特殊考虑了，因为如果直接复制指针，就不会受GC的管理，可能存在UAF问题。 分配好缓冲区之后，再对elemsize等成员赋值即完成了channel的创建。\nfunc makechan(t *chantype, size int) *hchan { elem := t.Elem // compiler checks this but be safe. // 元素的大小必须小于64K，因为hchan的elemsize类型为uint16，超过就会溢出 if elem.Size_ \u003e= 1\u003c\u003c16 { throw(\"makechan: invalid channel element type\") } if hchanSize%maxAlign != 0 || elem.Align_ \u003e maxAlign { throw(\"makechan: bad alignment\") } // 计算缓冲区大小（单位为字节），并检查大小是否溢出 mem, overflow := math.MulUintptr(elem.Size_, uintptr(size)) if overflow || mem \u003e maxAlloc-hchanSize || size \u003c 0 { panic(plainError(\"makechan: size out of range\")) } // Hchan does not contain pointers interesting for GC when elements stored in buf do not contain pointers. // buf points into the same allocation, elemtype is persistent. // SudoG's are referenced from their owning thread so they can't be collected. // TODO(dvyukov,rlh): Rethink when collector can move allocated objects. // 创建hchan结构体，并初始化c.buf，分为三种情况 var c *hchan switch { case mem == 0:\t// 无缓冲 或 元素大小为0（如chan struct{}） // Queue or element size is zero. c = (*hchan)(mallocgc(hchanSize, nil, true)) // Race detector uses this location for synchronization. c.buf = c.raceaddr() case !elem.Pointers():\t// 元素类型不是指针，直接在hchan之后分配缓冲区 // Elements do not contain pointers. // Allocate hchan and buf in one call. c = (*hchan)(mallocgc(hchanSize+mem, nil, true)) c.buf = add(unsafe.Pointer(c), hchanSize) default:\t// 有缓冲 且 元素类型是指针，需要特别对待（考虑GC） // Elements contain pointers. c = new(hchan) c.buf = mallocgc(mem, elem, true) } // 为其他成员赋值 c.elemsize = uint16(elem.Size_) c.elemtype = elem c.dataqsiz = uint(size) lockInit(\u0026c.lock, lockRankHchan) if debugChan { print(\"makechan: chan=\", c, \"; elemsize=\", elem.Size_, \"; dataqsiz=\", size, \"\\n\") } return c } 写入channel channel的写入可以分为两种：阻塞写和非阻塞写。\n// 阻塞写，如果c不可写，则一直阻塞，直到c可写时再被唤醒 c \u003c- v // 非阻塞写，用select + default，如果c不可写，则不会阻塞，而是直接执行default分支 select { case c \u003c- v: println(\"writen\") default: println(\"default\") } 对于非阻塞写的情况，Go会将其优化成如下方式，即调用selectnbsend()函数，selectnbsend()和阻塞写一样——最终调用chansend()。\n// compiler implements // //\tselect { //\tcase c \u003c- v: //\t... foo //\tdefault: //\t... bar //\t} // // as // //\tif selectnbsend(c, v) { //\t... foo //\t} else { //\t... bar //\t} func selectnbsend(c *hchan, elem unsafe.Pointer) (selected bool) { return chansend(c, elem, false, getcallerpc()) } 以下是chansend()函数简化版。总结来说写入逻辑为：\n对于非阻塞写，先尝试fast path，即在不加锁的情况下判断，如果channel未关闭，且循环缓冲区已满，则立即返回； 以下操作在加锁情况下执行 若channel已经关闭，则触发panic；（禁止向closed的channel写就是这么来的）； 若当前接收等待队列不为空，则直接把数据交给接受队列中的goroutine，省去了写入循环缓冲区的开销，也导致了channel不能保证FIFO。否则向下执行； 判断循环缓冲区是否已满，如果未满，则将数据写入循环缓冲区，并更新sendx和qcount；如果循环缓冲区已满，对于非阻塞写直接返回； 对于阻塞写，将自己加入等待写入队列，然后调用gopark触发调度； func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool { // 如果c是nil，且以非阻塞方式写入，则立即返回false，调用gopark让出执行权 if c == nil { if !block { return false } gopark(nil, nil, waitReasonChanSendNilChan, traceBlockForever, 2) throw(\"unreachable\") } // ...... // 如果是非阻塞方式读，则执行Fast path, 即在 [不加锁] 的情况下判断： // 如果channel未close，且循环缓冲区已满，则立即返回 if !block \u0026\u0026 c.closed == 0 \u0026\u0026 full(c) { return false } // ...... // 以下操作加锁了！ lock(\u0026c.lock) // 不允许向已经closed的channel写入，违反则触发panic if c.closed != 0 { unlock(\u0026c.lock) panic(plainError(\"send on closed channel\")) } // 如果接受队列部位空，则直接从接受队列取出一个接收者 // 避免了将数据写入循环缓冲区，所以可以看出channel不保证先进先出的顺序 :) if sg := c.recvq.dequeue(); sg != nil { // Found a waiting receiver. We pass the value we want to send // directly to the receiver, bypassing the channel buffer (if any). send(c, sg, ep, func() { unlock(\u0026c.lock) }, 3) return true } // 如果循环缓冲区未满，则将数据写入循环缓冲区，更新qcount和sendx if c.qcount \u003c c.dataqsiz { // Space is available in the channel buffer. Enqueue the element to send. qp := chanbuf(c, c.sendx) if raceenabled { racenotify(c, c.sendx, nil) } typedmemmove(c.elemtype, qp, ep) c.sendx++ if c.sendx == c.dataqsiz { c.sendx = 0 } c.qcount++ unlock(\u0026c.lock) return true } // 如果缓冲区还是空，且以非阻塞方式写入，则直接返回 if !block { unlock(\u0026c.lock) return false } // ...... // 将自己加入发送等待队列 c.sendq.enqueue(mysg) // 调用gopark触发调度 gopark(chanparkcommit, unsafe.Pointer(\u0026c.lock), waitReasonChanSend, traceBlockChanSend, 2) // ...... return true } 读出channel 理解了前面的写入channel就很好理解读出channel的操作了。和写入channel一样，读出channel也分为阻塞读和非阻塞读两种情况。\n// 阻塞读 v := \u003c-c // 非阻塞读，用select + default，如果c暂时没有数据，则不会啧啧，而是直接执行default分支 select { case v := \u003c-ch: println(v) default: println(\"default\") } 对于非阻塞读的情况，Go会将其优化成如下形式，即非阻塞读会调用selectnbrecv()，最终还是和阻塞读一样——调用chanrecv()。\n// compiler implements // //\tselect { //\tcase v, ok = \u003c-c: //\t... foo //\tdefault: //\t... bar //\t} // // as // //\tif selected, ok = selectnbrecv(\u0026v, c); selected { //\t... foo //\t} else { //\t... bar //\t} func selectnbrecv(elem unsafe.Pointer, c *hchan) (selected, received bool) { return chanrecv(c, elem, false) } 以下是chanrecv()函数的简化版。总结来说，读出逻辑为：\n对于非阻塞读，先尝试fast path，即在不加锁的情况下判断，如果循环接受队列为空，则立即返回； 以下操作在加锁的情况下执行： 若channel已经关闭，且循环缓冲区为空，则返回。否则继续执行； 如果发送等待队列不为空，则直接从发送等待队列的goroutine获取数据。否则继续执行； 如果循环缓冲区不为空，则从循环缓冲区读取数据并返回； 如果循环缓冲区为空，且是非阻塞读，则立即返回，否则将自己加入接收等待队列并调用gopark触发调度。 func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) { // 如果channel为nil，且是非阻塞读，直接返回，否则调用gopark触发调度 if c == nil { if !block { return } gopark(nil, nil, waitReasonChanReceiveNilChan, traceBlockForever, 2) throw(\"unreachable\") } // 如果非阻塞读，且循环缓冲区为空，则直接返回 // Fast path: check for failed non-blocking operation without acquiring the lock. if !block \u0026\u0026 empty(c) { if atomic.Load(\u0026c.closed) == 0 { // 如果channel已关闭，直接return return } } // 加锁保护 lock(\u0026c.lock) // 如果通道已关闭，且循环缓冲区没有数据，则返回 if c.closed != 0 { if c.qcount == 0 { if raceenabled { raceacquire(c.raceaddr()) } unlock(\u0026c.lock) if ep != nil { typedmemclr(c.elemtype, ep) } return true, false } // The channel has been closed, but the channel's buffer have data. } else { // Just found waiting sender with not closed. // 若发送等待队列不为空，则直接从发送等待队的goroutine接收数据 if sg := c.sendq.dequeue(); sg != nil { // Found a waiting sender. If buffer is size 0, receive value // directly from sender. Otherwise, receive from head of queue // and add sender's value to the tail of the queue (both map to // the same buffer slot because the queue is full). recv(c, sg, ep, func() { unlock(\u0026c.lock) }, 3) return true, true } } // 如果循环缓冲区不为空，则从循环缓冲区读取 if c.qcount \u003e 0 { // Receive directly from queue qp := chanbuf(c, c.recvx) if raceenabled { racenotify(c, c.recvx, nil) } if ep != nil { typedmemmove(c.elemtype, ep, qp) } typedmemclr(c.elemtype, qp) c.recvx++ if c.recvx == c.dataqsiz { c.recvx = 0 } c.qcount-- unlock(\u0026c.lock) return true, true } // 如果是非阻塞读，且未读到，则直接返回 if !block { unlock(\u0026c.lock) return false, false } // 如果是阻塞读，将自己放入接收等待队列 c.recvq.enqueue(mysg) // 触发调度 gopark(chanparkcommit, unsafe.Pointer(\u0026c.lock), waitReasonChanReceive, traceBlockChanRecv, 2) // ...... } 关闭channel 关闭channel在语法是是close(c)，实际上是调用了runtime.closechan()。关闭channel的逻辑如下：\n禁止关闭nil的channel，违反则触发panic； 禁止关闭已经被关闭的channel，这就是著名的close of closed channel； func closechan(c *hchan) { // 禁止关闭nil if c == nil { panic(plainError(\"close of nil channel\")) } // 加锁执行 lock(\u0026c.lock) // 禁止关闭已经被关闭的channel if c.closed != 0 { unlock(\u0026c.lock) panic(plainError(\"close of closed channel\")) } // 标记为已关闭 c.closed = 1 var glist gList // release all readers // 遍历接收等待队列，将队列中的goroutine加入唤醒队列 for { sg := c.recvq.dequeue() if sg == nil { break } if sg.elem != nil { typedmemclr(c.elemtype, sg.elem) sg.elem = nil } if sg.releasetime != 0 { sg.releasetime = cputicks() } gp := sg.g gp.param = unsafe.Pointer(sg) sg.success = false if raceenabled { raceacquireg(gp, c.raceaddr()) } glist.push(gp) } // release all writers (they will panic) // 遍历发送等待队列，将队列中的goroutine加入唤醒队列 for { sg := c.sendq.dequeue() if sg == nil { break } sg.elem = nil if sg.releasetime != 0 { sg.releasetime = cputicks() } gp := sg.g gp.param = unsafe.Pointer(sg) sg.success = false if raceenabled { raceacquireg(gp, c.raceaddr()) } glist.push(gp) } unlock(\u0026c.lock) // Ready all Gs now that we've dropped the channel lock. // 遍历唤醒队列，唤醒队列中的goroutine for !glist.empty() { gp := glist.pop() gp.schedlink = 0 goready(gp, 3) } } ","wordCount":"1229","inLanguage":"zh","datePublished":"2025-10-14T14:12:34+08:00","dateModified":"2025-10-14T14:12:34+08:00","author":{"@type":"Person","name":"rand0m"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://rand0m42195.github.io/posts/go-channel/"},"publisher":{"@type":"Organization","name":"rand0m's blog","logo":{"@type":"ImageObject","url":"https://rand0m42195.github.io/favicon.ico"}}}</script><link rel=icon href=/favicon.ico type=image/x-icon><link rel=icon href=/favicon-16x16.png type=image/png size=16x16><link rel=icon href=/favicon-32x32.png type=image/png size=32x32><link rel=icon href=/favicon-192x192.png type=image/png size=192x192><link rel=icon href=/favicon-512x512.png type=image/png size=512x512></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://rand0m42195.github.io/ accesskey=h title="rand0m's blog (Alt + H)">rand0m's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://rand0m42195.github.io/posts/ title=文章><span>文章</span></a></li><li><a href=https://rand0m42195.github.io/about/ title=关于><span>关于</span></a></li><li><a href=https://github.com/rand0m42195 title=GitHub><span>GitHub</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://rand0m42195.github.io/>主页</a>&nbsp;»&nbsp;<a href=https://rand0m42195.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Go Channel源码解读</h1><div class=post-meta><span title='2025-10-14 14:12:34 +0800 +0800'>十月 14, 2025</span>&nbsp;·&nbsp;6 分钟&nbsp;·&nbsp;rand0m</div></header><div class=post-content><blockquote><p><strong>“Don’t communicate by sharing memory, share memory by communicating.”</strong>
不要通过共享内存来通信，而要通过通信来共享内存。</p></blockquote><h1 id=channel-介绍>channel 介绍<a hidden class=anchor aria-hidden=true href=#channel-介绍>#</a></h1><p>channel是Go语言内置的一个非常重要的feature，相比其他语言，channel为Go提供了goroutine之间通信的独特方式。它和Linux的管道很像，goroutine可以向可写的channel写入数据，也可以从channel中读取数据，还可以关闭channel。这篇文章结合Go的源码来分析channel的实现原理，包括channel的创建、读、写和关闭。</p><h1 id=channel实现原理>channel实现原理<a hidden class=anchor aria-hidden=true href=#channel实现原理>#</a></h1><h2 id=hchan结构体>hchan结构体<a hidden class=anchor aria-hidden=true href=#hchan结构体>#</a></h2><p>Go语言的channel本质上是一个带锁的等待队列的循环缓冲区队列，它的源码在runtime/chan.go中，其实就是一个<a href="https://cs.opensource.google/go/go/+/refs/tags/go1.23.4:src/runtime/chan.go;l=34">hchan</a>结构体：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Go data-lang=Go><span class=line><span class=cl><span class=kd>type</span><span class=w> </span><span class=nx>hchan</span><span class=w> </span><span class=kd>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>qcount</span><span class=w>   </span><span class=kt>uint</span><span class=w>           </span><span class=c1>// total data in the queue</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>dataqsiz</span><span class=w> </span><span class=kt>uint</span><span class=w>           </span><span class=c1>// size of the circular queue</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>buf</span><span class=w>      </span><span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=w> </span><span class=c1>// points to an array of dataqsiz elements</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>elemsize</span><span class=w> </span><span class=kt>uint16</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>closed</span><span class=w>   </span><span class=kt>uint32</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>timer</span><span class=w>    </span><span class=o>*</span><span class=nx>timer</span><span class=w> </span><span class=c1>// timer feeding this chan</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>elemtype</span><span class=w> </span><span class=o>*</span><span class=nx>_type</span><span class=w> </span><span class=c1>// element type</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>sendx</span><span class=w>    </span><span class=kt>uint</span><span class=w>   </span><span class=c1>// send index</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>recvx</span><span class=w>    </span><span class=kt>uint</span><span class=w>   </span><span class=c1>// receive index</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>recvq</span><span class=w>    </span><span class=nx>waitq</span><span class=w>  </span><span class=c1>// list of recv waiters</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>sendq</span><span class=w>    </span><span class=nx>waitq</span><span class=w>  </span><span class=c1>// list of send waiters</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// lock protects all fields in hchan, as well as several</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// fields in sudogs blocked on this channel.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>	// Do not change another G&#39;s status while holding this lock</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// (in particular, do not ready a G), as this can deadlock</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// with stack shrinking.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>lock</span><span class=w> </span><span class=nx>mutex</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p><code>hchan</code>结构体各成员的含义如下：</p><ul><li>qcount: 循环缓冲区队列当前存放的数据量，<code>qcount = 0</code> 时缓冲区为<strong>空</strong>，<code>qcount = dataqsiz</code> 时缓冲区<strong>满</strong>；</li><li>dataqsiz: 循环缓冲区队列的容量（即<code>make(chan T, N)</code>时指定的**<code>N</code>**）；</li><li>buf: 指向循环缓冲区队列；</li><li>elemsize: channel元素大小（注意这里是uint16，所以大小不能超过65535字节）；</li><li>closed: 标识channel是否已经被关闭；</li><li>timer: 与channel关联的定时器，主要用于select和超时机制；</li><li>elemtype: channel元素的类型信息，runtime需要用它来确定elemsize；</li><li>sendx: 下一个要写入的循环缓冲区索引；</li><li>recvx: 下一个要读取的循环缓冲区索引；</li><li>recvq: 正在等待接收数据的goroutine队列，当缓冲区空且者无发送者时，尝试以阻塞方式读取channel的goroutine会被加入此队列；</li><li>sendq: 正在等待发送数据的goroutine队列，当无接收者且缓冲区已满时，尝试以阻塞方式读取channel的goroutine会被加入此队列；</li><li>lock: 保护整个hchan中所有成员的锁；</li></ul><p>这个结构体相对比较简单，各成员的功能也相对比较好理解，下面就分别介绍channel的创建、写入、读出、关闭的实现。</p><h2 id=创建channel>创建channel<a hidden class=anchor aria-hidden=true href=#创建channel>#</a></h2><p>Go语言中，使用channel之前需要先用<code>make</code>创建，有两种方式：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Go data-lang=Go><span class=line><span class=cl><span class=c1>// 方式一，创建无缓冲的channel</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nb>make</span><span class=p>(</span><span class=kd>chan</span><span class=w> </span><span class=kt>int</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 方式二，创建有缓冲的channel</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nb>make</span><span class=p>(</span><span class=kd>chan</span><span class=w> </span><span class=kt>int</span><span class=p>,</span><span class=w> </span><span class=mi>8</span><span class=p>)</span><span class=w>
</span></span></span></code></pre></div><p>无论是哪种方式创建的，Go的编译器都是调用<code>runtime.makechan()</code>来创建。从直觉上来看，channel的底层就是一个hchan结构体，创建channel就是创建一个结构体，并根据创建时提供的参数对结构体的相关成员初始化即可。以下是<a href="https://cs.opensource.google/go/go/+/refs/tags/go1.23.4:src/runtime/chan.go;l=73"><code>runtime.makechan()</code></a>的源码，makechan接受两个参数，第一个参数是channel元素类型相关的指针，第二个参数是缓冲区大小，无缓冲则为0。</p><p>在为<code>hchan</code>分配循环缓冲区时，源码考虑了三种情况：</p><ul><li>无缓冲 或 缓冲区大小为0，这种情况不需要分配缓冲区，所以只创建一个<code>hchan</code>本体即可；</li><li>有缓冲区，但是元素的类型不是指针，这种情况把数据写入channel时，只需要将要写的数据拷贝一份到循环缓冲区即可，所以就把hchan本体和缓冲区放在一起，申请一整块内存，并让buf指向hchan结束的位置即可；</li><li>有缓冲，且元素类型是指针，这种情况就需要特殊考虑了，因为如果直接复制指针，就不会受GC的管理，可能存在UAF问题。</li></ul><p>分配好缓冲区之后，再对<code>elemsize</code>等成员赋值即完成了channel的创建。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Go data-lang=Go><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>makechan</span><span class=p>(</span><span class=nx>t</span><span class=w> </span><span class=o>*</span><span class=nx>chantype</span><span class=p>,</span><span class=w> </span><span class=nx>size</span><span class=w> </span><span class=kt>int</span><span class=p>)</span><span class=w> </span><span class=o>*</span><span class=nx>hchan</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>elem</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>t</span><span class=p>.</span><span class=nx>Elem</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// compiler checks this but be safe.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 元素的大小必须小于64K，因为hchan的elemsize类型为uint16，超过就会溢出</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>elem</span><span class=p>.</span><span class=nx>Size_</span><span class=w> </span><span class=o>&gt;=</span><span class=w> </span><span class=mi>1</span><span class=o>&lt;&lt;</span><span class=mi>16</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>throw</span><span class=p>(</span><span class=s>&#34;makechan: invalid channel element type&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>hchanSize</span><span class=o>%</span><span class=nx>maxAlign</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=nx>elem</span><span class=p>.</span><span class=nx>Align_</span><span class=w> </span><span class=p>&gt;</span><span class=w> </span><span class=nx>maxAlign</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>throw</span><span class=p>(</span><span class=s>&#34;makechan: bad alignment&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 计算缓冲区大小（单位为字节），并检查大小是否溢出</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>mem</span><span class=p>,</span><span class=w> </span><span class=nx>overflow</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>math</span><span class=p>.</span><span class=nf>MulUintptr</span><span class=p>(</span><span class=nx>elem</span><span class=p>.</span><span class=nx>Size_</span><span class=p>,</span><span class=w> </span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>size</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>overflow</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=nx>mem</span><span class=w> </span><span class=p>&gt;</span><span class=w> </span><span class=nx>maxAlloc</span><span class=o>-</span><span class=nx>hchanSize</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=nx>size</span><span class=w> </span><span class=p>&lt;</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nb>panic</span><span class=p>(</span><span class=nf>plainError</span><span class=p>(</span><span class=s>&#34;makechan: size out of range&#34;</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// Hchan does not contain pointers interesting for GC when elements stored in buf do not contain pointers.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// buf points into the same allocation, elemtype is persistent.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// SudoG&#39;s are referenced from their owning thread so they can&#39;t be collected.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// TODO(dvyukov,rlh): Rethink when collector can move allocated objects.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 创建hchan结构体，并初始化c.buf，分为三种情况</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=kd>var</span><span class=w> </span><span class=nx>c</span><span class=w> </span><span class=o>*</span><span class=nx>hchan</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>switch</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>case</span><span class=w> </span><span class=nx>mem</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>0</span><span class=p>:</span><span class=w>	</span><span class=c1>// 无缓冲 或 元素大小为0（如chan struct{}）</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// Queue or element size is zero.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>c</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=p>(</span><span class=o>*</span><span class=nx>hchan</span><span class=p>)(</span><span class=nf>mallocgc</span><span class=p>(</span><span class=nx>hchanSize</span><span class=p>,</span><span class=w> </span><span class=kc>nil</span><span class=p>,</span><span class=w> </span><span class=kc>true</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// Race detector uses this location for synchronization.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>c</span><span class=p>.</span><span class=nx>buf</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>c</span><span class=p>.</span><span class=nf>raceaddr</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>case</span><span class=w> </span><span class=p>!</span><span class=nx>elem</span><span class=p>.</span><span class=nf>Pointers</span><span class=p>():</span><span class=w>	</span><span class=c1>// 元素类型不是指针，直接在hchan之后分配缓冲区</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// Elements do not contain pointers.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// Allocate hchan and buf in one call.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>c</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=p>(</span><span class=o>*</span><span class=nx>hchan</span><span class=p>)(</span><span class=nf>mallocgc</span><span class=p>(</span><span class=nx>hchanSize</span><span class=o>+</span><span class=nx>mem</span><span class=p>,</span><span class=w> </span><span class=kc>nil</span><span class=p>,</span><span class=w> </span><span class=kc>true</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>c</span><span class=p>.</span><span class=nx>buf</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nf>add</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>c</span><span class=p>),</span><span class=w> </span><span class=nx>hchanSize</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>default</span><span class=p>:</span><span class=w>	</span><span class=c1>// 有缓冲 且 元素类型是指针，需要特别对待（考虑GC）</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// Elements contain pointers.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>c</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nb>new</span><span class=p>(</span><span class=nx>hchan</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>c</span><span class=p>.</span><span class=nx>buf</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nf>mallocgc</span><span class=p>(</span><span class=nx>mem</span><span class=p>,</span><span class=w> </span><span class=nx>elem</span><span class=p>,</span><span class=w> </span><span class=kc>true</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 为其他成员赋值</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>c</span><span class=p>.</span><span class=nx>elemsize</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nb>uint16</span><span class=p>(</span><span class=nx>elem</span><span class=p>.</span><span class=nx>Size_</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>c</span><span class=p>.</span><span class=nx>elemtype</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>elem</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>c</span><span class=p>.</span><span class=nx>dataqsiz</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nb>uint</span><span class=p>(</span><span class=nx>size</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>lockInit</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>c</span><span class=p>.</span><span class=nx>lock</span><span class=p>,</span><span class=w> </span><span class=nx>lockRankHchan</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>debugChan</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nb>print</span><span class=p>(</span><span class=s>&#34;makechan: chan=&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>c</span><span class=p>,</span><span class=w> </span><span class=s>&#34;; elemsize=&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>elem</span><span class=p>.</span><span class=nx>Size_</span><span class=p>,</span><span class=w> </span><span class=s>&#34;; dataqsiz=&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>size</span><span class=p>,</span><span class=w> </span><span class=s>&#34;\n&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>return</span><span class=w> </span><span class=nx>c</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h2 id=写入channel>写入channel<a hidden class=anchor aria-hidden=true href=#写入channel>#</a></h2><p>channel的写入可以分为两种：<strong>阻塞写</strong>和<strong>非阻塞写</strong>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Go data-lang=Go><span class=line><span class=cl><span class=c1>// 阻塞写，如果c不可写，则一直阻塞，直到c可写时再被唤醒</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nx>c</span><span class=w> </span><span class=o>&lt;-</span><span class=w> </span><span class=nx>v</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 非阻塞写，用select + default，如果c不可写，则不会阻塞，而是直接执行default分支</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>select</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>case</span><span class=w> </span><span class=nx>c</span><span class=w> </span><span class=o>&lt;-</span><span class=w> </span><span class=nx>v</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nb>println</span><span class=p>(</span><span class=s>&#34;writen&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>default</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nb>println</span><span class=p>(</span><span class=s>&#34;default&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>对于<strong>非阻塞写</strong>的情况，Go会将其<a href="https://cs.opensource.google/go/go/+/refs/tags/go1.23.4:src/runtime/chan.go;l=736">优化</a>成如下方式，即调用<a href="https://cs.opensource.google/go/go/+/refs/tags/go1.23.4:src/runtime/chan.go;l=752"><code>selectnbsend()</code></a>函数，<code>selectnbsend()</code>和阻塞写一样——最终调用<code>chansend()</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Go data-lang=Go><span class=line><span class=cl><span class=c1>// compiler implements</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>//	select {</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//	case c &lt;- v:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//		... foo</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//	default:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//		... bar</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//	}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// as</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>//	if selectnbsend(c, v) {</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//		... foo</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//	} else {</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//		... bar</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//	}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>func</span><span class=w> </span><span class=nf>selectnbsend</span><span class=p>(</span><span class=nx>c</span><span class=w> </span><span class=o>*</span><span class=nx>hchan</span><span class=p>,</span><span class=w> </span><span class=nx>elem</span><span class=w> </span><span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>)</span><span class=w> </span><span class=p>(</span><span class=nx>selected</span><span class=w> </span><span class=kt>bool</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>return</span><span class=w> </span><span class=nf>chansend</span><span class=p>(</span><span class=nx>c</span><span class=p>,</span><span class=w> </span><span class=nx>elem</span><span class=p>,</span><span class=w> </span><span class=kc>false</span><span class=p>,</span><span class=w> </span><span class=nf>getcallerpc</span><span class=p>())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>以下是<a href="https://cs.opensource.google/go/go/+/refs/tags/go1.23.4:src/runtime/chan.go;l=171"><code>chansend()</code></a>函数简化版。总结来说写入逻辑为：</p><ul><li>对于<em>非阻塞</em>写，先尝试fast path，即在不加锁的情况下判断，如果channel未关闭，且循环缓冲区已满，则立即返回；</li><li>以下操作在加锁情况下执行<ul><li>若channel已经关闭，则触发panic；（禁止向closed的channel写就是这么来的）；</li><li>若当前接收等待队列不为空，则直接把数据交给接受队列中的goroutine，省去了写入循环缓冲区的开销，也导致了channel不能保证FIFO。否则向下执行；</li><li>判断循环缓冲区是否已满，如果未满，则将数据写入循环缓冲区，并更新<code>sendx</code>和<code>qcount</code>；如果循环缓冲区已满，对于非阻塞写直接返回；</li><li>对于阻塞写，将自己加入等待写入队列，然后调用gopark触发调度；</li></ul></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>chansend</span><span class=p>(</span><span class=nx>c</span><span class=w> </span><span class=o>*</span><span class=nx>hchan</span><span class=p>,</span><span class=w> </span><span class=nx>ep</span><span class=w> </span><span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>,</span><span class=w> </span><span class=nx>block</span><span class=w> </span><span class=kt>bool</span><span class=p>,</span><span class=w> </span><span class=nx>callerpc</span><span class=w> </span><span class=kt>uintptr</span><span class=p>)</span><span class=w> </span><span class=kt>bool</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 如果c是nil，且以非阻塞方式写入，则立即返回false，调用gopark让出执行权</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>c</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>if</span><span class=w> </span><span class=p>!</span><span class=nx>block</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=k>return</span><span class=w> </span><span class=kc>false</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>gopark</span><span class=p>(</span><span class=kc>nil</span><span class=p>,</span><span class=w> </span><span class=kc>nil</span><span class=p>,</span><span class=w> </span><span class=nx>waitReasonChanSendNilChan</span><span class=p>,</span><span class=w> </span><span class=nx>traceBlockForever</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>throw</span><span class=p>(</span><span class=s>&#34;unreachable&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// ......</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 如果是非阻塞方式读，则执行Fast path, 即在 [不加锁] 的情况下判断：</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 如果channel未close，且循环缓冲区已满，则立即返回</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=p>!</span><span class=nx>block</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=nx>c</span><span class=p>.</span><span class=nx>closed</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=nf>full</span><span class=p>(</span><span class=nx>c</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>return</span><span class=w> </span><span class=kc>false</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// ......</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// 以下操作加锁了！</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>lock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>c</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 不允许向已经closed的channel写入，违反则触发panic</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>c</span><span class=p>.</span><span class=nx>closed</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>c</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nb>panic</span><span class=p>(</span><span class=nf>plainError</span><span class=p>(</span><span class=s>&#34;send on closed channel&#34;</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 如果接受队列部位空，则直接从接受队列取出一个接收者</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 避免了将数据写入循环缓冲区，所以可以看出channel不保证先进先出的顺序 :)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>sg</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>c</span><span class=p>.</span><span class=nx>recvq</span><span class=p>.</span><span class=nf>dequeue</span><span class=p>();</span><span class=w> </span><span class=nx>sg</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// Found a waiting receiver. We pass the value we want to send</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// directly to the receiver, bypassing the channel buffer (if any).</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>send</span><span class=p>(</span><span class=nx>c</span><span class=p>,</span><span class=w> </span><span class=nx>sg</span><span class=p>,</span><span class=w> </span><span class=nx>ep</span><span class=p>,</span><span class=w> </span><span class=kd>func</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>c</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span><span class=w> </span><span class=p>},</span><span class=w> </span><span class=mi>3</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>return</span><span class=w> </span><span class=kc>true</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 如果循环缓冲区未满，则将数据写入循环缓冲区，更新qcount和sendx</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>c</span><span class=p>.</span><span class=nx>qcount</span><span class=w> </span><span class=p>&lt;</span><span class=w> </span><span class=nx>c</span><span class=p>.</span><span class=nx>dataqsiz</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// Space is available in the channel buffer. Enqueue the element to send.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>qp</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nf>chanbuf</span><span class=p>(</span><span class=nx>c</span><span class=p>,</span><span class=w> </span><span class=nx>c</span><span class=p>.</span><span class=nx>sendx</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>if</span><span class=w> </span><span class=nx>raceenabled</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nf>racenotify</span><span class=p>(</span><span class=nx>c</span><span class=p>,</span><span class=w> </span><span class=nx>c</span><span class=p>.</span><span class=nx>sendx</span><span class=p>,</span><span class=w> </span><span class=kc>nil</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>typedmemmove</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>elemtype</span><span class=p>,</span><span class=w> </span><span class=nx>qp</span><span class=p>,</span><span class=w> </span><span class=nx>ep</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>c</span><span class=p>.</span><span class=nx>sendx</span><span class=o>++</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>if</span><span class=w> </span><span class=nx>c</span><span class=p>.</span><span class=nx>sendx</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=nx>c</span><span class=p>.</span><span class=nx>dataqsiz</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nx>c</span><span class=p>.</span><span class=nx>sendx</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=mi>0</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>c</span><span class=p>.</span><span class=nx>qcount</span><span class=o>++</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>c</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>return</span><span class=w> </span><span class=kc>true</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 如果缓冲区还是空，且以非阻塞方式写入，则直接返回</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=p>!</span><span class=nx>block</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>c</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>return</span><span class=w> </span><span class=kc>false</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// ......</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 将自己加入发送等待队列</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>c</span><span class=p>.</span><span class=nx>sendq</span><span class=p>.</span><span class=nf>enqueue</span><span class=p>(</span><span class=nx>mysg</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// 调用gopark触发调度</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>gopark</span><span class=p>(</span><span class=nx>chanparkcommit</span><span class=p>,</span><span class=w> </span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>c</span><span class=p>.</span><span class=nx>lock</span><span class=p>),</span><span class=w> </span><span class=nx>waitReasonChanSend</span><span class=p>,</span><span class=w> </span><span class=nx>traceBlockChanSend</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// ......</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>return</span><span class=w> </span><span class=kc>true</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h2 id=读出channel>读出channel<a hidden class=anchor aria-hidden=true href=#读出channel>#</a></h2><p>理解了前面的写入channel就很好理解读出channel的操作了。和写入channel一样，读出channel也分为<strong>阻塞读</strong>和<strong>非阻塞读</strong>两种情况。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 阻塞读</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nx>v</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=o>&lt;-</span><span class=nx>c</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 非阻塞读，用select + default，如果c暂时没有数据，则不会啧啧，而是直接执行default分支</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>select</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>case</span><span class=w> </span><span class=nx>v</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=o>&lt;-</span><span class=nx>ch</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nb>println</span><span class=p>(</span><span class=nx>v</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>default</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nb>println</span><span class=p>(</span><span class=s>&#34;default&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>对于<strong>非阻塞读</strong>的情况，Go会将其<a href="https://cs.opensource.google/go/go/+/refs/tags/go1.23.4:src/runtime/chan.go;l=756">优化</a>成如下形式，即<strong>非阻塞读</strong>会调用<code>selectnbrecv()</code>，最终还是和阻塞读一样——调用<code>chanrecv()</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// compiler implements</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>//	select {</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//	case v, ok = &lt;-c:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//		... foo</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//	default:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//		... bar</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//	}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// as</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>//	if selected, ok = selectnbrecv(&amp;v, c); selected {</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//		... foo</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//	} else {</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//		... bar</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//	}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>func</span><span class=w> </span><span class=nf>selectnbrecv</span><span class=p>(</span><span class=nx>elem</span><span class=w> </span><span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>,</span><span class=w> </span><span class=nx>c</span><span class=w> </span><span class=o>*</span><span class=nx>hchan</span><span class=p>)</span><span class=w> </span><span class=p>(</span><span class=nx>selected</span><span class=p>,</span><span class=w> </span><span class=nx>received</span><span class=w> </span><span class=kt>bool</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>return</span><span class=w> </span><span class=nf>chanrecv</span><span class=p>(</span><span class=nx>c</span><span class=p>,</span><span class=w> </span><span class=nx>elem</span><span class=p>,</span><span class=w> </span><span class=kc>false</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>以下是<a href="https://cs.opensource.google/go/go/+/refs/tags/go1.23.4:src/runtime/chan.go;l=504"><code>chanrecv()</code></a>函数的简化版。总结来说，读出逻辑为：</p><ul><li>对于非阻塞读，先尝试fast path，即在不加锁的情况下判断，如果循环接受队列为空，则立即返回；</li><li>以下操作在加锁的情况下执行：<ul><li>若channel已经关闭，且循环缓冲区为空，则返回。否则继续执行；</li><li>如果发送等待队列不为空，则直接从发送等待队列的goroutine获取数据。否则继续执行；</li><li>如果循环缓冲区不为空，则从循环缓冲区读取数据并返回；</li><li>如果循环缓冲区为空，且是非阻塞读，则立即返回，否则将自己加入接收等待队列并调用gopark触发调度。</li></ul></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>chanrecv</span><span class=p>(</span><span class=nx>c</span><span class=w> </span><span class=o>*</span><span class=nx>hchan</span><span class=p>,</span><span class=w> </span><span class=nx>ep</span><span class=w> </span><span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>,</span><span class=w> </span><span class=nx>block</span><span class=w> </span><span class=kt>bool</span><span class=p>)</span><span class=w> </span><span class=p>(</span><span class=nx>selected</span><span class=p>,</span><span class=w> </span><span class=nx>received</span><span class=w> </span><span class=kt>bool</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// 如果channel为nil，且是非阻塞读，直接返回，否则调用gopark触发调度</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>c</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>if</span><span class=w> </span><span class=p>!</span><span class=nx>block</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=k>return</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>gopark</span><span class=p>(</span><span class=kc>nil</span><span class=p>,</span><span class=w> </span><span class=kc>nil</span><span class=p>,</span><span class=w> </span><span class=nx>waitReasonChanReceiveNilChan</span><span class=p>,</span><span class=w> </span><span class=nx>traceBlockForever</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>throw</span><span class=p>(</span><span class=s>&#34;unreachable&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// 如果非阻塞读，且循环缓冲区为空，则直接返回</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// Fast path: check for failed non-blocking operation without acquiring the lock.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=p>!</span><span class=nx>block</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=nf>empty</span><span class=p>(</span><span class=nx>c</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>if</span><span class=w> </span><span class=nx>atomic</span><span class=p>.</span><span class=nf>Load</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>c</span><span class=p>.</span><span class=nx>closed</span><span class=p>)</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=c1>// 如果channel已关闭，直接return</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=k>return</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// 加锁保护</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>lock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>c</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 如果通道已关闭，且循环缓冲区没有数据，则返回</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>c</span><span class=p>.</span><span class=nx>closed</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>if</span><span class=w> </span><span class=nx>c</span><span class=p>.</span><span class=nx>qcount</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=k>if</span><span class=w> </span><span class=nx>raceenabled</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>				</span><span class=nf>raceacquire</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nf>raceaddr</span><span class=p>())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>c</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=k>if</span><span class=w> </span><span class=nx>ep</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>				</span><span class=nf>typedmemclr</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>elemtype</span><span class=p>,</span><span class=w> </span><span class=nx>ep</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=k>return</span><span class=w> </span><span class=kc>true</span><span class=p>,</span><span class=w> </span><span class=kc>false</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// The channel has been closed, but the channel&#39;s buffer have data.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// Just found waiting sender with not closed.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 若发送等待队列不为空，则直接从发送等待队的goroutine接收数据</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>if</span><span class=w> </span><span class=nx>sg</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>c</span><span class=p>.</span><span class=nx>sendq</span><span class=p>.</span><span class=nf>dequeue</span><span class=p>();</span><span class=w> </span><span class=nx>sg</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=c1>// Found a waiting sender. If buffer is size 0, receive value</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=c1>// directly from sender. Otherwise, receive from head of queue</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=c1>// and add sender&#39;s value to the tail of the queue (both map to</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=c1>// the same buffer slot because the queue is full).</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nf>recv</span><span class=p>(</span><span class=nx>c</span><span class=p>,</span><span class=w> </span><span class=nx>sg</span><span class=p>,</span><span class=w> </span><span class=nx>ep</span><span class=p>,</span><span class=w> </span><span class=kd>func</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>c</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span><span class=w> </span><span class=p>},</span><span class=w> </span><span class=mi>3</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=k>return</span><span class=w> </span><span class=kc>true</span><span class=p>,</span><span class=w> </span><span class=kc>true</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 如果循环缓冲区不为空，则从循环缓冲区读取</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>c</span><span class=p>.</span><span class=nx>qcount</span><span class=w> </span><span class=p>&gt;</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// Receive directly from queue</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>qp</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nf>chanbuf</span><span class=p>(</span><span class=nx>c</span><span class=p>,</span><span class=w> </span><span class=nx>c</span><span class=p>.</span><span class=nx>recvx</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>if</span><span class=w> </span><span class=nx>raceenabled</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nf>racenotify</span><span class=p>(</span><span class=nx>c</span><span class=p>,</span><span class=w> </span><span class=nx>c</span><span class=p>.</span><span class=nx>recvx</span><span class=p>,</span><span class=w> </span><span class=kc>nil</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>if</span><span class=w> </span><span class=nx>ep</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nf>typedmemmove</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>elemtype</span><span class=p>,</span><span class=w> </span><span class=nx>ep</span><span class=p>,</span><span class=w> </span><span class=nx>qp</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>typedmemclr</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>elemtype</span><span class=p>,</span><span class=w> </span><span class=nx>qp</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>c</span><span class=p>.</span><span class=nx>recvx</span><span class=o>++</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>if</span><span class=w> </span><span class=nx>c</span><span class=p>.</span><span class=nx>recvx</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=nx>c</span><span class=p>.</span><span class=nx>dataqsiz</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nx>c</span><span class=p>.</span><span class=nx>recvx</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=mi>0</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>c</span><span class=p>.</span><span class=nx>qcount</span><span class=o>--</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>c</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>return</span><span class=w> </span><span class=kc>true</span><span class=p>,</span><span class=w> </span><span class=kc>true</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 如果是非阻塞读，且未读到，则直接返回</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=p>!</span><span class=nx>block</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>c</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>return</span><span class=w> </span><span class=kc>false</span><span class=p>,</span><span class=w> </span><span class=kc>false</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// 如果是阻塞读，将自己放入接收等待队列</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>c</span><span class=p>.</span><span class=nx>recvq</span><span class=p>.</span><span class=nf>enqueue</span><span class=p>(</span><span class=nx>mysg</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// 触发调度</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>gopark</span><span class=p>(</span><span class=nx>chanparkcommit</span><span class=p>,</span><span class=w> </span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>c</span><span class=p>.</span><span class=nx>lock</span><span class=p>),</span><span class=w> </span><span class=nx>waitReasonChanReceive</span><span class=p>,</span><span class=w> </span><span class=nx>traceBlockChanRecv</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// ......</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h2 id=关闭channel>关闭channel<a hidden class=anchor aria-hidden=true href=#关闭channel>#</a></h2><p>关闭channel在语法是是<code>close(c)</code>，实际上是调用了<a href="https://cs.opensource.google/go/go/+/refs/tags/go1.23.4:src/runtime/chan.go;l=397"><code>runtime.closechan()</code></a>。关闭channel的逻辑如下：</p><ul><li>禁止关闭nil的channel，违反则触发panic；</li><li>禁止关闭已经被关闭的channel，这就是著名的<strong>close of closed channel</strong>；</li><li></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>closechan</span><span class=p>(</span><span class=nx>c</span><span class=w> </span><span class=o>*</span><span class=nx>hchan</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 禁止关闭nil</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>c</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nb>panic</span><span class=p>(</span><span class=nf>plainError</span><span class=p>(</span><span class=s>&#34;close of nil channel&#34;</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 加锁执行</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>lock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>c</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 禁止关闭已经被关闭的channel</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>c</span><span class=p>.</span><span class=nx>closed</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>c</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nb>panic</span><span class=p>(</span><span class=nf>plainError</span><span class=p>(</span><span class=s>&#34;close of closed channel&#34;</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// 标记为已关闭</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>c</span><span class=p>.</span><span class=nx>closed</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=mi>1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=kd>var</span><span class=w> </span><span class=nx>glist</span><span class=w> </span><span class=nx>gList</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// release all readers</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 遍历接收等待队列，将队列中的goroutine加入唤醒队列</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>for</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>sg</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>c</span><span class=p>.</span><span class=nx>recvq</span><span class=p>.</span><span class=nf>dequeue</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>if</span><span class=w> </span><span class=nx>sg</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=k>break</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>if</span><span class=w> </span><span class=nx>sg</span><span class=p>.</span><span class=nx>elem</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nf>typedmemclr</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>elemtype</span><span class=p>,</span><span class=w> </span><span class=nx>sg</span><span class=p>.</span><span class=nx>elem</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nx>sg</span><span class=p>.</span><span class=nx>elem</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=kc>nil</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>if</span><span class=w> </span><span class=nx>sg</span><span class=p>.</span><span class=nx>releasetime</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nx>sg</span><span class=p>.</span><span class=nx>releasetime</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nf>cputicks</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>gp</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>sg</span><span class=p>.</span><span class=nx>g</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>gp</span><span class=p>.</span><span class=nx>param</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>sg</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>sg</span><span class=p>.</span><span class=nx>success</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=kc>false</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>if</span><span class=w> </span><span class=nx>raceenabled</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nf>raceacquireg</span><span class=p>(</span><span class=nx>gp</span><span class=p>,</span><span class=w> </span><span class=nx>c</span><span class=p>.</span><span class=nf>raceaddr</span><span class=p>())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>glist</span><span class=p>.</span><span class=nf>push</span><span class=p>(</span><span class=nx>gp</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// release all writers (they will panic)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 遍历发送等待队列，将队列中的goroutine加入唤醒队列</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>for</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>sg</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>c</span><span class=p>.</span><span class=nx>sendq</span><span class=p>.</span><span class=nf>dequeue</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>if</span><span class=w> </span><span class=nx>sg</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=k>break</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>sg</span><span class=p>.</span><span class=nx>elem</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=kc>nil</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>if</span><span class=w> </span><span class=nx>sg</span><span class=p>.</span><span class=nx>releasetime</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nx>sg</span><span class=p>.</span><span class=nx>releasetime</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nf>cputicks</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>gp</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>sg</span><span class=p>.</span><span class=nx>g</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>gp</span><span class=p>.</span><span class=nx>param</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>sg</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>sg</span><span class=p>.</span><span class=nx>success</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=kc>false</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>if</span><span class=w> </span><span class=nx>raceenabled</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nf>raceacquireg</span><span class=p>(</span><span class=nx>gp</span><span class=p>,</span><span class=w> </span><span class=nx>c</span><span class=p>.</span><span class=nf>raceaddr</span><span class=p>())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>glist</span><span class=p>.</span><span class=nf>push</span><span class=p>(</span><span class=nx>gp</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>c</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// Ready all Gs now that we&#39;ve dropped the channel lock.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 遍历唤醒队列，唤醒队列中的goroutine</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>for</span><span class=w> </span><span class=p>!</span><span class=nx>glist</span><span class=p>.</span><span class=nf>empty</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>gp</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>glist</span><span class=p>.</span><span class=nf>pop</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>gp</span><span class=p>.</span><span class=nx>schedlink</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=mi>0</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>goready</span><span class=p>(</span><span class=nx>gp</span><span class=p>,</span><span class=w> </span><span class=mi>3</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://rand0m42195.github.io/tags/go/>Go</a></li><li><a href=https://rand0m42195.github.io/tags/channel/>Channel</a></li><li><a href=https://rand0m42195.github.io/tags/source/>Source</a></li></ul><nav class=paginav><a class=next href=https://rand0m42195.github.io/posts/go-pitfall-guide/><span class=title>下一页 »</span><br><span>Go语言常见错误分析</span></a></nav></footer><div id=comments><script src=https://giscus.app/client.js data-repo=rand0m42195/rand0m42195.github.io data-repo-id=R_kgDOPzDcOw data-category=Announcements data-category-id=DIC_kwDOPzDcO84CvpUm data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=en crossorigin=anonymous async></script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://rand0m42195.github.io/>rand0m's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>