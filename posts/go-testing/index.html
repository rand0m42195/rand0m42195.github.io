<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Go Testing | rand0m's blog</title><meta name=keywords content="Go,Testing,Fuzzing"><meta name=description content="TL; DR
本文介绍了Go原生支持的testing的两种测试方法（包内测试和包外测试）和Go支持的四种测试类型（TestXxxx、FuzzXxxx、BenchmarkXxxx和ExampleXxxx）以及使用IDE提示的run test/debug test和手动执行go test命令的区别。和实际项目开发中的被测对象相比，本文的示例比较简单，只是用于说明如何编写四种Go原生支持的测试函数。
Testing
测试的意义
测试是软件生命周期中一个重要部分，测试能带来很多好处：

减少代码缺陷，提升软件质量；
起到文档说明的作用，降低使用门槛；
加深开发人员对代码的理解，提高开发人员的自信；
提高软件开发效率；
&mldr;&mldr;

Go Testing
Go对test有很好的支持，go专门提供了用于测试的test子命令，测试代码需要写在以go项目中以_test.go结尾的文件中。Go提供了包内测试和包外测试，测试类型又可分为四种：TestXxxx、BenchmarkXxxx、FuzzXxx、ExampleXxx。
包内测试 vs 包外测试
包内测试
包内测试面向实现。包内测试可以访问包内的所有符号（包括未导出的符号）；测试代码的测试数据构造和测试逻辑通常与被测包的数据结构以及具体实现逻辑紧密结合。因此，如果修改了被测包的数据结构/实现逻辑，一般需要同步调整包内测试代码。
包外测试
包外测试面向接口。包外测试只能访问被测包导出的API；被测包的API是与外部交互的契约，契约一旦确定就应该长期保持稳定和向前兼容。因此一般修改被测包内部的数据结构和具体实现逻辑不影响包外测试代码。
四种测试类型
目前Go支持4种测试类型：四种测试方法的命名分别为：TestXxxx、BenchmarkXxxx、FuzzXxx和ExampleXxx。
TestXxxx
**用途：**用来检查被测代码的输出是否符合预期，最常用的一种测试类型。
**示例：**实现一个查找最长无重复子串的函数；(直接运行）
// mytest/mytest.go
// leetcode problem_3: https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/
func LengthOfLongestSubstring(s string) int {
    if len(s) == 0 {
        return 0
    }

    // 哈希集合，记录每个字符是否出现过
    m := map[byte]int{}
    n := len(s)
    // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动
    rk, ans := -1, 0
    for i := 0; i < n; i++ {
        if i != 0 {
            // 左指针向右移动一格，移除一个字符
            delete(m, s[i-1])
        }
        for rk+1 < n && m[s[rk+1]] == 0 {
            // 不断地移动右指针
            m[s[rk+1]]++
            rk++
        }
        // 第 i 到 rk 个字符是一个极长的无重复字符子串
        ans = max(ans, rk-i+1)
    }
    return ans
}

func max(x, y int) int {
    if x < y {
        return y
    }
    return x
}
如何验证这个函数是否符合预期？可以写一个简单的main函数，构造一些测试用例，然后调用这个函数。但是Go有自己的测试方法，只需要在被测代码的目录下创建一个以_test.go结尾的文件，并编写一个测试函数即可："><meta name=author content="rand0m"><link rel=canonical href=https://rand0m42195.github.io/posts/go-testing/><link crossorigin=anonymous href=/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://rand0m42195.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://rand0m42195.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://rand0m42195.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://rand0m42195.github.io/apple-touch-icon.png><link rel=mask-icon href=https://rand0m42195.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://rand0m42195.github.io/posts/go-testing/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://rand0m42195.github.io/posts/go-testing/"><meta property="og:site_name" content="rand0m's blog"><meta property="og:title" content="Go Testing"><meta property="og:description" content="TL; DR 本文介绍了Go原生支持的testing的两种测试方法（包内测试和包外测试）和Go支持的四种测试类型（TestXxxx、FuzzXxxx、BenchmarkXxxx和ExampleXxxx）以及使用IDE提示的run test/debug test和手动执行go test命令的区别。和实际项目开发中的被测对象相比，本文的示例比较简单，只是用于说明如何编写四种Go原生支持的测试函数。
Testing 测试的意义 测试是软件生命周期中一个重要部分，测试能带来很多好处：
减少代码缺陷，提升软件质量； 起到文档说明的作用，降低使用门槛； 加深开发人员对代码的理解，提高开发人员的自信； 提高软件开发效率； …… Go Testing Go对test有很好的支持，go专门提供了用于测试的test子命令，测试代码需要写在以go项目中以_test.go结尾的文件中。Go提供了包内测试和包外测试，测试类型又可分为四种：TestXxxx、BenchmarkXxxx、FuzzXxx、ExampleXxx。
包内测试 vs 包外测试 包内测试 包内测试面向实现。包内测试可以访问包内的所有符号（包括未导出的符号）；测试代码的测试数据构造和测试逻辑通常与被测包的数据结构以及具体实现逻辑紧密结合。因此，如果修改了被测包的数据结构/实现逻辑，一般需要同步调整包内测试代码。
包外测试 包外测试面向接口。包外测试只能访问被测包导出的API；被测包的API是与外部交互的契约，契约一旦确定就应该长期保持稳定和向前兼容。因此一般修改被测包内部的数据结构和具体实现逻辑不影响包外测试代码。
四种测试类型 目前Go支持4种测试类型：四种测试方法的命名分别为：TestXxxx、BenchmarkXxxx、FuzzXxx和ExampleXxx。
TestXxxx **用途：**用来检查被测代码的输出是否符合预期，最常用的一种测试类型。
**示例：**实现一个查找最长无重复子串的函数；(直接运行）
// mytest/mytest.go // leetcode problem_3: https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/ func LengthOfLongestSubstring(s string) int { if len(s) == 0 { return 0 } // 哈希集合，记录每个字符是否出现过 m := map[byte]int{} n := len(s) // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动 rk, ans := -1, 0 for i := 0; i < n; i++ { if i != 0 { // 左指针向右移动一格，移除一个字符 delete(m, s[i-1]) } for rk+1 < n && m[s[rk+1]] == 0 { // 不断地移动右指针 m[s[rk+1]]++ rk++ } // 第 i 到 rk 个字符是一个极长的无重复字符子串 ans = max(ans, rk-i+1) } return ans } func max(x, y int) int { if x < y { return y } return x } 如何验证这个函数是否符合预期？可以写一个简单的main函数，构造一些测试用例，然后调用这个函数。但是Go有自己的测试方法，只需要在被测代码的目录下创建一个以_test.go结尾的文件，并编写一个测试函数即可："><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-10-14T06:39:46+08:00"><meta property="article:modified_time" content="2025-10-14T06:39:46+08:00"><meta property="article:tag" content="Go"><meta property="article:tag" content="Testing"><meta property="article:tag" content="Fuzzing"><meta name=twitter:card content="summary"><meta name=twitter:title content="Go Testing"><meta name=twitter:description content="TL; DR
本文介绍了Go原生支持的testing的两种测试方法（包内测试和包外测试）和Go支持的四种测试类型（TestXxxx、FuzzXxxx、BenchmarkXxxx和ExampleXxxx）以及使用IDE提示的run test/debug test和手动执行go test命令的区别。和实际项目开发中的被测对象相比，本文的示例比较简单，只是用于说明如何编写四种Go原生支持的测试函数。
Testing
测试的意义
测试是软件生命周期中一个重要部分，测试能带来很多好处：

减少代码缺陷，提升软件质量；
起到文档说明的作用，降低使用门槛；
加深开发人员对代码的理解，提高开发人员的自信；
提高软件开发效率；
&mldr;&mldr;

Go Testing
Go对test有很好的支持，go专门提供了用于测试的test子命令，测试代码需要写在以go项目中以_test.go结尾的文件中。Go提供了包内测试和包外测试，测试类型又可分为四种：TestXxxx、BenchmarkXxxx、FuzzXxx、ExampleXxx。
包内测试 vs 包外测试
包内测试
包内测试面向实现。包内测试可以访问包内的所有符号（包括未导出的符号）；测试代码的测试数据构造和测试逻辑通常与被测包的数据结构以及具体实现逻辑紧密结合。因此，如果修改了被测包的数据结构/实现逻辑，一般需要同步调整包内测试代码。
包外测试
包外测试面向接口。包外测试只能访问被测包导出的API；被测包的API是与外部交互的契约，契约一旦确定就应该长期保持稳定和向前兼容。因此一般修改被测包内部的数据结构和具体实现逻辑不影响包外测试代码。
四种测试类型
目前Go支持4种测试类型：四种测试方法的命名分别为：TestXxxx、BenchmarkXxxx、FuzzXxx和ExampleXxx。
TestXxxx
**用途：**用来检查被测代码的输出是否符合预期，最常用的一种测试类型。
**示例：**实现一个查找最长无重复子串的函数；(直接运行）
// mytest/mytest.go
// leetcode problem_3: https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/
func LengthOfLongestSubstring(s string) int {
    if len(s) == 0 {
        return 0
    }

    // 哈希集合，记录每个字符是否出现过
    m := map[byte]int{}
    n := len(s)
    // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动
    rk, ans := -1, 0
    for i := 0; i < n; i++ {
        if i != 0 {
            // 左指针向右移动一格，移除一个字符
            delete(m, s[i-1])
        }
        for rk+1 < n && m[s[rk+1]] == 0 {
            // 不断地移动右指针
            m[s[rk+1]]++
            rk++
        }
        // 第 i 到 rk 个字符是一个极长的无重复字符子串
        ans = max(ans, rk-i+1)
    }
    return ans
}

func max(x, y int) int {
    if x < y {
        return y
    }
    return x
}
如何验证这个函数是否符合预期？可以写一个简单的main函数，构造一些测试用例，然后调用这个函数。但是Go有自己的测试方法，只需要在被测代码的目录下创建一个以_test.go结尾的文件，并编写一个测试函数即可："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://rand0m42195.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Go Testing","item":"https://rand0m42195.github.io/posts/go-testing/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Go Testing","name":"Go Testing","description":"TL; DR 本文介绍了Go原生支持的testing的两种测试方法（包内测试和包外测试）和Go支持的四种测试类型（TestXxxx、FuzzXxxx、BenchmarkXxxx和ExampleXxxx）以及使用IDE提示的run test/debug test和手动执行go test命令的区别。和实际项目开发中的被测对象相比，本文的示例比较简单，只是用于说明如何编写四种Go原生支持的测试函数。\nTesting 测试的意义 测试是软件生命周期中一个重要部分，测试能带来很多好处：\n减少代码缺陷，提升软件质量； 起到文档说明的作用，降低使用门槛； 加深开发人员对代码的理解，提高开发人员的自信； 提高软件开发效率； \u0026hellip;\u0026hellip; Go Testing Go对test有很好的支持，go专门提供了用于测试的test子命令，测试代码需要写在以go项目中以_test.go结尾的文件中。Go提供了包内测试和包外测试，测试类型又可分为四种：TestXxxx、BenchmarkXxxx、FuzzXxx、ExampleXxx。\n包内测试 vs 包外测试 包内测试 包内测试面向实现。包内测试可以访问包内的所有符号（包括未导出的符号）；测试代码的测试数据构造和测试逻辑通常与被测包的数据结构以及具体实现逻辑紧密结合。因此，如果修改了被测包的数据结构/实现逻辑，一般需要同步调整包内测试代码。\n包外测试 包外测试面向接口。包外测试只能访问被测包导出的API；被测包的API是与外部交互的契约，契约一旦确定就应该长期保持稳定和向前兼容。因此一般修改被测包内部的数据结构和具体实现逻辑不影响包外测试代码。\n四种测试类型 目前Go支持4种测试类型：四种测试方法的命名分别为：TestXxxx、BenchmarkXxxx、FuzzXxx和ExampleXxx。\nTestXxxx **用途：**用来检查被测代码的输出是否符合预期，最常用的一种测试类型。\n**示例：**实现一个查找最长无重复子串的函数；(直接运行）\n// mytest/mytest.go // leetcode problem_3: https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/ func LengthOfLongestSubstring(s string) int { if len(s) == 0 { return 0 } // 哈希集合，记录每个字符是否出现过 m := map[byte]int{} n := len(s) // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动 rk, ans := -1, 0 for i := 0; i \u0026lt; n; i++ { if i != 0 { // 左指针向右移动一格，移除一个字符 delete(m, s[i-1]) } for rk+1 \u0026lt; n \u0026amp;\u0026amp; m[s[rk+1]] == 0 { // 不断地移动右指针 m[s[rk+1]]++ rk++ } // 第 i 到 rk 个字符是一个极长的无重复字符子串 ans = max(ans, rk-i+1) } return ans } func max(x, y int) int { if x \u0026lt; y { return y } return x } 如何验证这个函数是否符合预期？可以写一个简单的main函数，构造一些测试用例，然后调用这个函数。但是Go有自己的测试方法，只需要在被测代码的目录下创建一个以_test.go结尾的文件，并编写一个测试函数即可：\n","keywords":["Go","Testing","Fuzzing"],"articleBody":"TL; DR 本文介绍了Go原生支持的testing的两种测试方法（包内测试和包外测试）和Go支持的四种测试类型（TestXxxx、FuzzXxxx、BenchmarkXxxx和ExampleXxxx）以及使用IDE提示的run test/debug test和手动执行go test命令的区别。和实际项目开发中的被测对象相比，本文的示例比较简单，只是用于说明如何编写四种Go原生支持的测试函数。\nTesting 测试的意义 测试是软件生命周期中一个重要部分，测试能带来很多好处：\n减少代码缺陷，提升软件质量； 起到文档说明的作用，降低使用门槛； 加深开发人员对代码的理解，提高开发人员的自信； 提高软件开发效率； …… Go Testing Go对test有很好的支持，go专门提供了用于测试的test子命令，测试代码需要写在以go项目中以_test.go结尾的文件中。Go提供了包内测试和包外测试，测试类型又可分为四种：TestXxxx、BenchmarkXxxx、FuzzXxx、ExampleXxx。\n包内测试 vs 包外测试 包内测试 包内测试面向实现。包内测试可以访问包内的所有符号（包括未导出的符号）；测试代码的测试数据构造和测试逻辑通常与被测包的数据结构以及具体实现逻辑紧密结合。因此，如果修改了被测包的数据结构/实现逻辑，一般需要同步调整包内测试代码。\n包外测试 包外测试面向接口。包外测试只能访问被测包导出的API；被测包的API是与外部交互的契约，契约一旦确定就应该长期保持稳定和向前兼容。因此一般修改被测包内部的数据结构和具体实现逻辑不影响包外测试代码。\n四种测试类型 目前Go支持4种测试类型：四种测试方法的命名分别为：TestXxxx、BenchmarkXxxx、FuzzXxx和ExampleXxx。\nTestXxxx **用途：**用来检查被测代码的输出是否符合预期，最常用的一种测试类型。\n**示例：**实现一个查找最长无重复子串的函数；(直接运行）\n// mytest/mytest.go // leetcode problem_3: https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/ func LengthOfLongestSubstring(s string) int { if len(s) == 0 { return 0 } // 哈希集合，记录每个字符是否出现过 m := map[byte]int{} n := len(s) // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动 rk, ans := -1, 0 for i := 0; i \u003c n; i++ { if i != 0 { // 左指针向右移动一格，移除一个字符 delete(m, s[i-1]) } for rk+1 \u003c n \u0026\u0026 m[s[rk+1]] == 0 { // 不断地移动右指针 m[s[rk+1]]++ rk++ } // 第 i 到 rk 个字符是一个极长的无重复字符子串 ans = max(ans, rk-i+1) } return ans } func max(x, y int) int { if x \u003c y { return y } return x } 如何验证这个函数是否符合预期？可以写一个简单的main函数，构造一些测试用例，然后调用这个函数。但是Go有自己的测试方法，只需要在被测代码的目录下创建一个以_test.go结尾的文件，并编写一个测试函数即可：\n// mytest/mytest_test.go import \"testing\" func TestLengthOfLongestSubstringV0(t *testing.T) { case1 := \"abcabcbb\" // \"abc\" got := LengthOfLongestSubstring(case1) if got != 3 { t.Fatalf(\"input: %s, want: %d, got: %d\", case1, 3, got) } } 在上面测试文件所在的目录下，执行如下命令即可：\n$ go test -run=^TestLengthOfLongestSubstringV0$ PASS ok letsgo/mytest 0.005s 为了验证上面函数的正确性和健壮性，需要更多的测试用例，下面是一个有5个测试用例的测试函数：\n// mytest/mytest_test.go func TestLengthOfLongestSubstringV1(t *testing.T) { case1 := \"a\" // \" \", 1 case2 := \"ab\" // \"a\", 1 case3 := \"abcabcbb\" // \"abc\", 3 case4 := \"bbbbb\" // \"b\", 1 case5 := \"pwwkew\" // \"wke\", 3 exp1 := 1 exp2 := 2 exp3 := 3 exp4 := 1 exp5 := 3 got := LengthOfLongestSubstring(case1) if got != exp1 { t.Fatalf(\"input: %s, want: %d, got: %d\", case1, exp1, got) } got = LengthOfLongestSubstring(case2) if got != exp2 { t.Fatalf(\"input: %s, want: %d, got: %d\", case2, exp2, got) } got = LengthOfLongestSubstring(case3) if got != exp3 { t.Fatalf(\"input: %s, want: %d, got: %d\", case3, exp3, got) } got = LengthOfLongestSubstring(case4) if got != exp4 { t.Fatalf(\"input: %s, want: %d, got: %d\", case4, exp4, got) } got = LengthOfLongestSubstring(case5) if got != exp5 { t.Fatalf(\"input: %s, want: %d, got: %d\", case5, exp5, got) } } 执行上面的测试用例，全部通过。TestLengthOfLongestSubstringV1和TestLengthOfLongestSubstringV0比，多了四个测试用例，但是代码行数增加了许多，而且增加的代码逻辑完全相同。如果继续增加测试用例，测试代码的行数将会成倍增长，对后面维护测试代码不利。\n$ go test -run=^TestLengthOfLongestSubstringV1$ PASS ok letsgo/mytest 0.007s 使用table-driven方法编写测试用例，可以避免上述问题，示例如下。table-driven专注于测试用例的构造，所有的测试用例使用同一套测试代码，随着开发的迭代，测试代码的维护一般只需要添加测试用例即可。\n// mytest/mytest_test.go func TestLengthOfLongestSubstringV2(t *testing.T) { tests := []struct { input string expect int }{ {\"a\", 1}, {\"ab\", 2}, {\"abcabcbb\", 3}, {\"bbbbb\", 1}, {\"pwwkew\", 3}, } for i, tt := range tests { got := LengthOfLongestSubstring(tt.input) if got != tt.expect { t.Errorf(\"case_%d: %s, expect: %d, got: %d\", i, tt.input, tt.expect, got) // Error vs Fatal } } } 测试上述测试代码，全部通过！\n$ go test -run=^TestLengthOfLongestSubstringV2$ PASS ok letsgo/mytest 0.006s Go还提供了统计代码覆盖率的工具，可以使用代码覆盖率统计工具来统计代码的覆盖率，对于测试代码，只需要在执行go test时添加-cover参数即可。从下面的输出可以看到被测代码的覆盖率为93.8%。\n$ go test -run=^TestLengthOfLongestSubstringV2$ -cover PASS coverage: 93.8% of statements ok letsgo/mytest 0.008s 如果想继续提高代码的覆盖率，就需要知道当前的测试用例覆盖了哪些代码，还有哪些代码没有覆盖到。Go也提供了相关的功能，只需要给go test命令添加-coverprofile参数，让go test生成代码覆盖信息即可。\n# 将代码覆盖信息输出到 c.out 文件 $ go test -cover -coverprofile c.out -run=^TestLengthOfLongestSubstringV2$ PASS coverage: 93.8% of statements ok letsgo/mytest 0.005s 查看c.out文件，c.out是一个文本文件，从文件内容上看，大概可以猜到，源码行号后面的0/1标识代码是否被执行过。但是这个文件内容对人类不太友好，可以使用go tool cover将其转换成html查看(具体操作执行go tool cover查看帮助)。\n# 查看文件类型 $ file c.out c.out: ASCII text # 查看文件内容 $ cat c.out mode: set letsgo/mytest/mytest.go:4.45,5.17 1 1 letsgo/mytest/mytest.go:5.17,7.3 1 0 letsgo/mytest/mytest.go:10.2,14.25 4 1 letsgo/mytest/mytest.go:14.25,15.13 1 1 letsgo/mytest/mytest.go:15.13,18.4 1 1 letsgo/mytest/mytest.go:19.3,19.35 1 1 letsgo/mytest/mytest.go:19.35,23.4 2 1 letsgo/mytest/mytest.go:25.3,25.25 1 1 letsgo/mytest/mytest.go:27.2,27.12 1 1 letsgo/mytest/mytest.go:30.24,31.11 1 1 letsgo/mytest/mytest.go:31.11,33.3 1 1 letsgo/mytest/mytest.go:34.2,34.10 1 1 使用go tool cover就可以发现源码中的如下的if内的代码没有被执行，因此只需要构造一个空字符串（长度为0）作为测试用例，即可使代码覆盖率达到100%。\n// mytest/mytest_test.go func LengthOfLongestSubstring(s string) int { if len(s) == 0 { return 0 } // ...... } 那么问题来了：\n实际项目中测试几乎做不到100%，如何提高代码的测试用例？ 代码覆盖率很高甚至达到了100%就能保证代码没有bug吗？ 针对第二个问题，答案是否定的。举个很简单的例子(如下)，只要调用这个函数，代码的覆盖率就是100%，但是这个代码明显存在除0错误。虽然代码覆盖率达到了100%不能保证代码没有bug，但是代码覆盖率仍然是越高越好。\nfunc MyDiv(a, b, c int) int { return a / (b - c) } 有没有方法能提高代码覆盖率，发现移植代码的bug呢？答案是肯定的，那就是fuzzing！\nFuzzXxx **用途：**用于挖掘深藏的bug。\n思想：变异+反馈（物竞天择，适者生存）；\n原理：将被测对象看作一个有输入和输出的系统，对系统输入不同的测试用例，统计系统内部的代码执行情况和输出，并将有意义的输入作为种子进行变异再作为输入，不断重复。\n模糊测试的流行得益于模糊测试工具AFL，Go对fuzz的原生支持是从Go1.18开始的。使用Go的Fuzz并不难，只要准备初始测试用例即可。下面举个例子：\n被测代码如下，还是求一个字符串的最长字串的实现，和前面的代码相比，这里调用了一个bugInHere函数，这个函数里面隐藏了一个bug。\n// fuzz/fuzz.go package fuzz func bugInHere(s string) string { if len(s) \u003e 8 { if s[0] == 'p' { if s[1] == 'a' { if s[2] == 'n' { if s[3] == 'i' { if s[4] == 'c' { if s[5] == ' ' { if s[6] == 'b' { if s[7] == 'u' { if s[8] == 'g' { return s[:10] } } } } } } } } } } return s } func LengthOfLongestSubstring(s string) int { if len(s) == 0 { return 0 } s = bugInHere(s) // panic // 哈希集合，记录每个字符是否出现过 m := map[byte]int{} n := len(s) // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动 rk, ans := -1, 0 for i := 0; i \u003c n; i++ { if i != 0 { // 左指针向右移动一格，移除一个字符 delete(m, s[i-1]) } for rk+1 \u003c n \u0026\u0026 m[s[rk+1]] == 0 { // 不断地移动右指针 m[s[rk+1]]++ rk++ } // 第 i 到 rk 个字符是一个极长的无重复字符子串 ans = max(ans, rk-i+1) } return ans } func max(x, y int) int { if x \u003c y { return y } return x } 下面尝试fuzz上面的代码，fuzz测试代码如下，fuzz测试代码很简单，只需要两部即可：\n创建初始化测试用例并添加到testing.F中； 调用f.Fuzz开始fuzz。 // fuzz/fuzz_test.go func FuzzLengthOfLongestSubstring(f *testing.F) { // 创建初始测试用例（种子） tests := []string{\"\"} for _, ts := range tests { f.Add(ts) } // 开始 fuzz f.Fuzz(func(t *testing.T, a string) { LengthOfLongestSubstring(a) }) } 执行下面的命令开始fuzz，从输出可以看到程序运行了32s触发了程序的bug，导致panic了。触发bug的输入在当前目录下的testdata/fuzz/FuzzLenthOfLongestSubstring目录下。\n# 执行fuzz命令 $ go test -fuzz=^FuzzLengthOfLongestSubstring$ -v === RUN FuzzLengthOfLongestSubstringV2 === RUN FuzzLengthOfLongestSubstringV2/seed#0 === RUN FuzzLengthOfLongestSubstringV2/seed#1 === RUN FuzzLengthOfLongestSubstringV2/seed#2 === RUN FuzzLengthOfLongestSubstringV2/seed#3 === RUN FuzzLengthOfLongestSubstringV2/seed#4 === RUN FuzzLengthOfLongestSubstringV2/seed#5 --- PASS: FuzzLengthOfLongestSubstringV2 (0.00s) --- PASS: FuzzLengthOfLongestSubstringV2/seed#0 (0.00s) --- PASS: FuzzLengthOfLongestSubstringV2/seed#1 (0.00s) --- PASS: FuzzLengthOfLongestSubstringV2/seed#2 (0.00s) --- PASS: FuzzLengthOfLongestSubstringV2/seed#3 (0.00s) --- PASS: FuzzLengthOfLongestSubstringV2/seed#4 (0.00s) --- PASS: FuzzLengthOfLongestSubstringV2/seed#5 (0.00s) === RUN FuzzLengthOfLongestSubstring fuzz: elapsed: 0s, gathering baseline coverage: 0/22 completed fuzz: elapsed: 0s, gathering baseline coverage: 22/22 completed, now fuzzing with 8 workers fuzz: elapsed: 3s, execs: 220261 (73409/sec), new interesting: 0 (total: 22) fuzz: elapsed: 6s, execs: 442482 (74025/sec), new interesting: 0 (total: 22) fuzz: elapsed: 9s, execs: 675241 (77628/sec), new interesting: 0 (total: 22) fuzz: elapsed: 12s, execs: 893474 (72688/sec), new interesting: 0 (total: 22) fuzz: elapsed: 15s, execs: 1127763 (78167/sec), new interesting: 0 (total: 22) fuzz: elapsed: 18s, execs: 1364191 (78804/sec), new interesting: 0 (total: 22) fuzz: elapsed: 21s, execs: 1581999 (72609/sec), new interesting: 0 (total: 22) fuzz: elapsed: 24s, execs: 1829063 (82274/sec), new interesting: 0 (total: 22) fuzz: elapsed: 27s, execs: 2057236 (76138/sec), new interesting: 0 (total: 22) fuzz: elapsed: 30s, execs: 2295217 (79327/sec), new interesting: 0 (total: 22) fuzz: elapsed: 32s, execs: 2446099 (68996/sec), new interesting: 0 (total: 22) --- FAIL: FuzzLengthOfLongestSubstring (32.19s) --- FAIL: FuzzLengthOfLongestSubstring (0.00s) testing.go:1504: panic: runtime error: slice bounds out of range [:10] with length 9 goroutine 314427 [running]: runtime/debug.Stack() /usr/local/go/src/runtime/debug/stack.go:24 +0x9b testing.tRunner.func1() /usr/local/go/src/testing/testing.go:1504 +0x1ee panic({0x5e8300?, 0xc00001b9e0?}) /usr/local/go/src/runtime/panic.go:914 +0x21f letsgo/fuzz.bugInHere(...) /home/nop/happycoding/wtfs/letsgo/fuzz/fuzz.go:15 letsgo/fuzz.LengthOfLongestSubstring({0xc0091ae3c5, 0x9}) /home/nop/happycoding/wtfs/letsgo/fuzz/fuzz.go:36 +0x885 letsgo/fuzz.FuzzLengthOfLongestSubstring.func1(0x0?, {0xc0091ae3c5?, 0x0?}) /home/nop/happycoding/wtfs/letsgo/fuzz/fuzz_test.go:38 +0x3b reflect.Value.call({0x5c37c0?, 0x607ad8?, 0x13?}, {0x5f83fc, 0x4}, {0xc0091b8150, 0x2, 0x2?}) /usr/local/go/src/reflect/value.go:596 +0xce7 reflect.Value.Call({0x5c37c0?, 0x607ad8?, 0x72f7c0?}, {0xc0091b8150?, 0x5f7a00?, 0x52220d?}) /usr/local/go/src/reflect/value.go:380 +0xb9 testing.(*F).Fuzz.func1.1(0x406420?) /usr/local/go/src/testing/fuzz.go:335 +0x347 testing.tRunner(0xc0091b5520, 0xc0091ab3b0) /usr/local/go/src/testing/testing.go:1595 +0xff created by testing.(*F).Fuzz.func1 in goroutine 18 /usr/local/go/src/testing/fuzz.go:322 +0x597 Failing input written to testdata/fuzz/FuzzLengthOfLongestSubstring/87820115886ac14a To re-run: go test -run=FuzzLengthOfLongestSubstring/87820115886ac14a === NAME FAIL exit status 1 FAIL letsgo/fuzz 32.208s # 触发bug的测试用例在 testdata/fuzz/FuzzLengthOfLongestSubstring 目录下。 $ tree . ├── fuzz.go ├── fuzz_test.go └── testdata └── fuzz └── FuzzLengthOfLongestSubstring └── 87820115886ac14a # 触发程序bug的测试用例 $ cat testdata/fuzz/FuzzLengthOfLongestSubstring/87820115886ac14a go test fuzz v1 string(\"panic bug\") 更多细节见：\ntesting包文档； Tutorial: Getting started with fuzzing BenchmarkXxx **用途：**测试代码的性能（执行效率，内存分配、内存使用情况等）。\nInline vs Noinline； 用benchmark来对比一下inline和noinline的性能差距有多大。默认情况下go build在编译源码时会对源码进行优化，其中一项就是将比较简单的函数inline，为了禁止函数编译器对函数做inline优化，可以使用*//go:noinline**。*\n// fuzz/fuzz_test.go func InlineMax(a, b int) int { if a \u003e b { return a } return b } //go:noinline func NonInlineMax(a, b int) int { if a \u003e b { return a } return b } 对上面两个函数做性能分析，测试代码如下：\n// bench/bench_test.go var Result int func BenchmarkMaxInline(b *testing.B) { var r int for i := 0; i \u003c b.N; i++ { r = InlineMax(-1, 1) } Result = r } func BenchmarkMaxNonInline(b *testing.B) { var r int for i := 0; i \u003c b.N; i++ { r = NonInlineMax(-1, 1) } Result = r } 执行上面的测试代码，输出了每个测试函数1s时间的执行情况：BenchmarkMaxInline-8执行了1000000000次，平均每次迭代耗时0.7953 ns，BenchmarkMaxNonInline-8执行了447639264次，平均每次迭代耗时3.841 ns。\n$ go test -bench=^BenchmarkMax -run=\"\" goos: linux goarch: amd64 pkg: letsgo/bench cpu: 12th Gen Intel(R) Core(TM) i7-12700H BenchmarkMaxInline-8 1000000000 0.7953 ns/op BenchmarkMaxNonInline-8 447639264 3.841 ns/op PASS ok letsgo/bench 2.939s Concat string； 下面实现了三种拼接字符串的方法，具体实现方式分别为：使用字符串的+操作符拼接、使用fmt.Sprintf拼接和使用strings.Join拼接。\n// bench/bench.go func ConcatStringByOperator(sl []string) string { var s string for _, v := range sl { s += v } return s } func ConcatStringBySprintf(sl []string) string { var s string for _, v := range sl { s = fmt.Sprintf(\"%s%s\", s, v) } return s } func ConcatStringByJoin(sl []string) string { return strings.Join(sl, \"\") } 测试代码如下：\n// bench/bench_test.go var sl = []string{ \"Rob Pike \", \"Robert Griesemer \", \"Ken Thompson \", } func BenchmarkConcatStringByOperator(b *testing.B) { for n := 0; n \u003c b.N; n++ { ConcatStringByOperator(sl) } } func BenchmarkConcatStringBySprintf(b *testing.B) { for n := 0; n \u003c b.N; n++ { ConcatStringBySprintf(sl) } } func BenchmarkConcatStringByJoin(b *testing.B) { for n := 0; n \u003c b.N; n++ { ConcatStringByJoin(sl) } } 执行上面的测试代码，上面的字符串的拼接需额外的内存，可以在go test命令后添加-benchmem来查看内存分配情况。具体输出如下，以BenchmarkConcatStringByOperator-8输出为例：\n1s内迭代了4614390次，平均每次迭代耗时240.6 ns，平均每次迭代申请了80bytes，平均每次迭代申请了2次内存。\n$ go test -run=\"\" -bench=^BenchmarkConcat -benchmem goos: linux goarch: amd64 pkg: letsgo/bench cpu: 12th Gen Intel(R) Core(TM) i7-12700H BenchmarkConcatStringByOperator-8 4614390 240.6 ns/op 80 B/op 2 allocs/op BenchmarkConcatStringBySprintf-8 1096496 1024 ns/op 176 B/op 8 allocs/op BenchmarkConcatStringByJoin-8 7350830 152.6 ns/op 48 B/op 1 allocs/op PASS ok letsgo/bench 4.872s Start/Stop timer； go test默认给每个Benchmark函数分配1s时间，但是有些情况下需要先初始化，然后再进行测试，如果初始化比较耗时，可能会影响基准测试的测试结果。解决方法就是在执行耗时的操作之前停止计时，等到耗时操作执行完之后再继续计时。测试代码如下，用Init模拟一个比较耗时的操作。\n// bench/bench_test.go func Init() { time.Sleep(500 * time.Millisecond) } func BenchmarkWithoutInit(b *testing.B) { for n := 0; n \u003c b.N; n++ { ConcatStringByJoin(sl) } } func BenchmarkWithInitV1(b *testing.B) { Init() for n := 0; n \u003c b.N; n++ { ConcatStringByJoin(sl) } } func BenchmarkWithInitV2(b *testing.B) { b.StopTimer() Init() b.StartTimer() // b.ResetTimer() for n := 0; n \u003c b.N; n++ { ConcatStringByJoin(sl) } } 测试结果如下，可以看到BenchmarkWithoutInit-8和BenchmarkWithInitV2-8的平均每个迭代执行时间差不多。而未使用StopTimer和StartTimer的BenchmarkWithInitV1-8 的平均每个迭代的执行差不多时间是BenchmarkWithInitV2-8的2倍。\n$ go test -run=\"\" -bench=^BenchmarkWith goos: linux goarch: amd64 pkg: letsgo/bench cpu: 12th Gen Intel(R) Core(TM) i7-12700H BenchmarkWithoutInit-8 8317146 154.0 ns/op BenchmarkWithInitV1-8 4181710 272.9 ns/op BenchmarkWithInitV2-8 7411749 153.3 ns/op PASS ok letsgo/bench 18.368s ExampleXxx 用于检测被测代码的输出是否符合预期，重点关注输出（仅仅指stdout）。\n测试代码：\n// example/example.go package example func HelloWrold() { fmt.Println(\"hello world\") } func HelloWorld2() { fmt.Fprintf(os.Stderr, \"hello world\") } 测试代码：\n// example/example_test.go package example_test import ( \"letsgo/example\" ) func ExampleHelloWorld() { example.HelloWorld() // Output: hello world } func ExampleHelloWorld2() { example.HelloWorld2() // Output: } 执行上面的测试代码：\n$ go test -run=^Example -v  ✔ ╱ nop@nop-vm  11:06:48 上午 === RUN ExampleHelloWorld --- PASS: ExampleHelloWorld (0.00s) === RUN ExampleHelloWorld2 hello world--- PASS: ExampleHelloWorld2 (0.00s) === RUN ExampleMap --- PASS: ExampleMap (0.00s) PASS ok letsgo/example 0.007s 另外，如果输出结果顺序是不确定的，可以用Unordered output，如：\n// example/example.go func PrintMap() { colors := map[string]string{ \"red\": \"红\", \"green\": \"绿\", \"blue\": \"蓝\", } for k, v := range colors { fmt.Println(k, v) } } // example/example_test.go package example_test func ExamplePrintMap() { example.PrintMap() // Unordered output: // red 红 // blue 蓝 // green 绿 } 其他 testdata testdata是一个特殊的目录名，go在编译源码时会自动忽略这个文件中的文件（包括*.go文件），testdata一般用于存放测试需要的数据或者生成的数据。\ngo test 执行go test命令时，go test的处理步骤如下：\n生成测试程序的主函数（我们编写的测代码其实是这个测试主函数需要的数据）； 调用go build编译测试程序，生成可执行文件； 调用可执行文件，执行测试函数； 删除步骤2生成的可执行文件； go test用法 go test命令的用法，可以使用go help test命令查看。\n$ go help test usage: go test [build/test flags] [packages] [build/test flags \u0026 test binary flags] ...... The test binary also accepts flags that control execution of the test; these flags are also accessible by 'go test'. See 'go help testflag' for details. For more about build flags, see 'go help build'. For more about specifying packages, see 'go help packages'. 从给出的 usage 可以看到go test的参数分为三类，分别如下：\nBuild flags：即编译参数，具体参数见go help build； Test flags：go test所需的参数（如-c、-json），具体参数见go help test； Binary flags：测试程序所需的参数，具体参数见go help testflag。 接下来结合命令进行说明：\n这条命令中的参数-run=^TestLengthOfLongestSubstringV0$和-cover属于binary flag。\n$ go test -run=^TestLengthOfLongestSubstringV0$ -cover 这条命令中的-c参数愉test flag参数，作用是让go test直接生成可执行文件，但是不执行可执行文件。\n$ go test -c 这条命令中的-gcflags=\"-m -N -l\"属于build flags。\n$ go test -gcflags=\"-m -N -l\" IDE自动执行 vs 手动执行 和IDE自动执行相比，手动执行更灵活：\n可以一次执行多个（可以不是全部）测试函数； 可以指定输出信息（如输出格式-json，显示详情-v，输出代码覆盖率信息-cover，指定超时时间-timeout等）； ","wordCount":"1743","inLanguage":"zh","datePublished":"2025-10-14T06:39:46+08:00","dateModified":"2025-10-14T06:39:46+08:00","author":{"@type":"Person","name":"rand0m"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://rand0m42195.github.io/posts/go-testing/"},"publisher":{"@type":"Organization","name":"rand0m's blog","logo":{"@type":"ImageObject","url":"https://rand0m42195.github.io/favicon.ico"}}}</script><link rel=icon href=/favicon.ico type=image/x-icon><link rel=icon href=/favicon-16x16.png type=image/png size=16x16><link rel=icon href=/favicon-32x32.png type=image/png size=32x32><link rel=icon href=/favicon-192x192.png type=image/png size=192x192><link rel=icon href=/favicon-512x512.png type=image/png size=512x512></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://rand0m42195.github.io/ accesskey=h title="rand0m's blog (Alt + H)">rand0m's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://rand0m42195.github.io/posts/ title=文章><span>文章</span></a></li><li><a href=https://rand0m42195.github.io/about/ title=关于><span>关于</span></a></li><li><a href=https://github.com/rand0m42195 title=GitHub><span>GitHub</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://rand0m42195.github.io/>主页</a>&nbsp;»&nbsp;<a href=https://rand0m42195.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Go Testing</h1><div class=post-meta><span title='2025-10-14 06:39:46 +0800 +0800'>十月 14, 2025</span>&nbsp;·&nbsp;9 分钟&nbsp;·&nbsp;rand0m</div></header><div class=post-content><h1 id=tl-dr>TL; DR<a hidden class=anchor aria-hidden=true href=#tl-dr>#</a></h1><p>本文介绍了Go原生支持的testing的两种测试方法（包内测试和包外测试）和Go支持的四种测试类型（<code>TestXxxx</code>、<code>FuzzXxxx</code>、<code>BenchmarkXxxx</code>和<code>ExampleXxxx</code>）以及使用IDE提示的<code>run test</code>/<code>debug test</code>和手动执行<code>go test</code>命令的区别。和实际项目开发中的被测对象相比，本文的示例比较简单，只是用于说明如何编写四种Go原生支持的测试函数。</p><h1 id=testing>Testing<a hidden class=anchor aria-hidden=true href=#testing>#</a></h1><h2 id=测试的意义>测试的意义<a hidden class=anchor aria-hidden=true href=#测试的意义>#</a></h2><p>测试是软件生命周期中一个重要部分，测试能带来很多好处：</p><ul><li>减少代码缺陷，提升软件质量；</li><li>起到文档说明的作用，降低使用门槛；</li><li>加深开发人员对代码的理解，提高开发人员的自信；</li><li>提高软件开发效率；</li><li>&mldr;&mldr;</li></ul><h2 id=go-testing>Go Testing<a hidden class=anchor aria-hidden=true href=#go-testing>#</a></h2><p>Go对test有很好的支持，go专门提供了用于测试的test子命令，测试代码需要写在以go项目中以_test.go结尾的文件中。Go提供了包内测试和包外测试，测试类型又可分为四种：<code>TestXxxx</code>、<code>BenchmarkXxxx</code>、<code>FuzzXxx</code>、<code>ExampleXxx</code>。</p><h3 id=包内测试-vs-包外测试>包内测试 vs 包外测试<a hidden class=anchor aria-hidden=true href=#包内测试-vs-包外测试>#</a></h3><h4 id=包内测试>包内测试<a hidden class=anchor aria-hidden=true href=#包内测试>#</a></h4><p>包内测试面向实现。包内测试可以访问包内的所有符号（包括未导出的符号）；测试代码的测试数据构造和测试逻辑通常与被测包的数据结构以及具体实现逻辑紧密结合。因此，如果修改了被测包的数据结构/实现逻辑，一般需要同步调整包内测试代码。</p><h4 id=包外测试>包外测试<a hidden class=anchor aria-hidden=true href=#包外测试>#</a></h4><p>包外测试面向接口。包外测试只能访问被测包导出的API；被测包的API是与外部交互的契约，契约一旦确定就应该长期保持稳定和向前兼容。因此一般修改被测包内部的数据结构和具体实现逻辑不影响包外测试代码。</p><h4 id=四种测试类型>四种测试类型<a hidden class=anchor aria-hidden=true href=#四种测试类型>#</a></h4><p>目前Go支持4种测试类型：四种测试方法的命名分别为：<code>TestXxxx</code>、<code>BenchmarkXxxx</code>、<code>FuzzXxx</code>和<code>ExampleXxx</code>。</p><h5 id=testxxxx>TestXxxx<a hidden class=anchor aria-hidden=true href=#testxxxx>#</a></h5><p>**用途：**用来检查被测代码的输出是否符合预期，最常用的一种测试类型。</p><p>**示例：**实现一个查找<a href=https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/>最长无重复子串</a>的函数；(<a href=https://go.dev/play/p/PHbBzl0pPsC>直接运行</a>）</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Go data-lang=Go><span class=line><span class=cl><span class=c1>// mytest/mytest.go</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// leetcode problem_3: https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>func</span><span class=w> </span><span class=nf>LengthOfLongestSubstring</span><span class=p>(</span><span class=nx>s</span><span class=w> </span><span class=kt>string</span><span class=p>)</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nb>len</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=mi>0</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 哈希集合，记录每个字符是否出现过</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>m</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>map</span><span class=p>[</span><span class=kt>byte</span><span class=p>]</span><span class=kt>int</span><span class=p>{}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>n</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nb>len</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>rk</span><span class=p>,</span><span class=w> </span><span class=nx>ans</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=o>-</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=p>&lt;</span><span class=w> </span><span class=nx>n</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=o>++</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// 左指针向右移动一格，移除一个字符</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nb>delete</span><span class=p>(</span><span class=nx>m</span><span class=p>,</span><span class=w> </span><span class=nx>s</span><span class=p>[</span><span class=nx>i</span><span class=o>-</span><span class=mi>1</span><span class=p>])</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=nx>rk</span><span class=o>+</span><span class=mi>1</span><span class=w> </span><span class=p>&lt;</span><span class=w> </span><span class=nx>n</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=nx>m</span><span class=p>[</span><span class=nx>s</span><span class=p>[</span><span class=nx>rk</span><span class=o>+</span><span class=mi>1</span><span class=p>]]</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// 不断地移动右指针</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nx>m</span><span class=p>[</span><span class=nx>s</span><span class=p>[</span><span class=nx>rk</span><span class=o>+</span><span class=mi>1</span><span class=p>]]</span><span class=o>++</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nx>rk</span><span class=o>++</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 第 i 到 rk 个字符是一个极长的无重复字符子串</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>ans</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nb>max</span><span class=p>(</span><span class=nx>ans</span><span class=p>,</span><span class=w> </span><span class=nx>rk</span><span class=o>-</span><span class=nx>i</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=nx>ans</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>func</span><span class=w> </span><span class=nb>max</span><span class=p>(</span><span class=nx>x</span><span class=p>,</span><span class=w> </span><span class=nx>y</span><span class=w> </span><span class=kt>int</span><span class=p>)</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nx>x</span><span class=w> </span><span class=p>&lt;</span><span class=w> </span><span class=nx>y</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=nx>y</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=nx>x</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>如何验证这个函数是否符合预期？可以写一个简单的main函数，构造一些测试用例，然后调用这个函数。但是Go有自己的测试方法，只需要在被测代码的目录下创建一个以<code>_test.go</code>结尾的文件，并编写一个测试函数即可：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Go data-lang=Go><span class=line><span class=cl><span class=c1>// mytest/mytest_test.go</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kn>import</span><span class=w> </span><span class=s>&#34;testing&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>func</span><span class=w> </span><span class=nf>TestLengthOfLongestSubstringV0</span><span class=p>(</span><span class=nx>t</span><span class=w> </span><span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>T</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>case1</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=s>&#34;abcabcbb&#34;</span><span class=w> </span><span class=c1>// &#34;abc&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>got</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nf>LengthOfLongestSubstring</span><span class=p>(</span><span class=nx>case1</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nx>got</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=mi>3</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>t</span><span class=p>.</span><span class=nf>Fatalf</span><span class=p>(</span><span class=s>&#34;input: %s, want: %d, got: %d&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>case1</span><span class=p>,</span><span class=w> </span><span class=mi>3</span><span class=p>,</span><span class=w> </span><span class=nx>got</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>在上面测试文件所在的目录下，执行如下命令即可：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>$ go <span class=nb>test</span> -run<span class=o>=</span>^TestLengthOfLongestSubstringV0$
</span></span><span class=line><span class=cl>PASS
</span></span><span class=line><span class=cl>ok      letsgo/mytest   0.005s
</span></span></code></pre></div><p>为了验证上面函数的正确性和健壮性，需要更多的测试用例，下面是一个有5个测试用例的测试函数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Go data-lang=Go><span class=line><span class=cl><span class=c1>// mytest/mytest_test.go</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>func</span><span class=w> </span><span class=nf>TestLengthOfLongestSubstringV1</span><span class=p>(</span><span class=nx>t</span><span class=w> </span><span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>T</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>case1</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=s>&#34;a&#34;</span><span class=w>        </span><span class=c1>// &#34; &#34;, 1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>case2</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=s>&#34;ab&#34;</span><span class=w>       </span><span class=c1>// &#34;a&#34;, 1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>case3</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=s>&#34;abcabcbb&#34;</span><span class=w> </span><span class=c1>// &#34;abc&#34;, 3</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>case4</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=s>&#34;bbbbb&#34;</span><span class=w>    </span><span class=c1>// &#34;b&#34;, 1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>case5</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=s>&#34;pwwkew&#34;</span><span class=w>   </span><span class=c1>// &#34;wke&#34;, 3</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>exp1</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=mi>1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>exp2</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=mi>2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>exp3</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=mi>3</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>exp4</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=mi>1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>exp5</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=mi>3</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>got</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nf>LengthOfLongestSubstring</span><span class=p>(</span><span class=nx>case1</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nx>got</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=nx>exp1</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>t</span><span class=p>.</span><span class=nf>Fatalf</span><span class=p>(</span><span class=s>&#34;input: %s, want: %d, got: %d&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>case1</span><span class=p>,</span><span class=w> </span><span class=nx>exp1</span><span class=p>,</span><span class=w> </span><span class=nx>got</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>got</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nf>LengthOfLongestSubstring</span><span class=p>(</span><span class=nx>case2</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nx>got</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=nx>exp2</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>t</span><span class=p>.</span><span class=nf>Fatalf</span><span class=p>(</span><span class=s>&#34;input: %s, want: %d, got: %d&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>case2</span><span class=p>,</span><span class=w> </span><span class=nx>exp2</span><span class=p>,</span><span class=w> </span><span class=nx>got</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>got</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nf>LengthOfLongestSubstring</span><span class=p>(</span><span class=nx>case3</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nx>got</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=nx>exp3</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>t</span><span class=p>.</span><span class=nf>Fatalf</span><span class=p>(</span><span class=s>&#34;input: %s, want: %d, got: %d&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>case3</span><span class=p>,</span><span class=w> </span><span class=nx>exp3</span><span class=p>,</span><span class=w> </span><span class=nx>got</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>got</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nf>LengthOfLongestSubstring</span><span class=p>(</span><span class=nx>case4</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nx>got</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=nx>exp4</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>t</span><span class=p>.</span><span class=nf>Fatalf</span><span class=p>(</span><span class=s>&#34;input: %s, want: %d, got: %d&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>case4</span><span class=p>,</span><span class=w> </span><span class=nx>exp4</span><span class=p>,</span><span class=w> </span><span class=nx>got</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>got</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nf>LengthOfLongestSubstring</span><span class=p>(</span><span class=nx>case5</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nx>got</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=nx>exp5</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>t</span><span class=p>.</span><span class=nf>Fatalf</span><span class=p>(</span><span class=s>&#34;input: %s, want: %d, got: %d&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>case5</span><span class=p>,</span><span class=w> </span><span class=nx>exp5</span><span class=p>,</span><span class=w> </span><span class=nx>got</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>执行上面的测试用例，全部通过。<code>TestLengthOfLongestSubstringV1</code>和<code>TestLengthOfLongestSubstringV0</code>比，多了四个测试用例，但是代码行数增加了许多，而且增加的代码逻辑完全相同。如果继续增加测试用例，测试代码的行数将会成倍增长，对后面维护测试代码不利。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Go data-lang=Go><span class=line><span class=cl><span class=err>$</span><span class=w> </span><span class=k>go</span><span class=w> </span><span class=nx>test</span><span class=w> </span><span class=o>-</span><span class=nx>run</span><span class=p>=^</span><span class=nx>TestLengthOfLongestSubstringV1</span><span class=err>$</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nx>PASS</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nx>ok</span><span class=w>      </span><span class=nx>letsgo</span><span class=o>/</span><span class=nx>mytest</span><span class=w>   </span><span class=mf>0.007</span><span class=nx>s</span><span class=w>
</span></span></span></code></pre></div><p>使用<code>table-driven</code>方法编写测试用例，可以避免上述问题，示例如下。<code>table-driven</code>专注于测试用例的构造，所有的测试用例使用同一套测试代码，随着开发的迭代，测试代码的维护一般只需要添加测试用例即可。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Go data-lang=Go><span class=line><span class=cl><span class=c1>// mytest/mytest_test.go</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>func</span><span class=w> </span><span class=nf>TestLengthOfLongestSubstringV2</span><span class=p>(</span><span class=nx>t</span><span class=w> </span><span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>T</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>tests</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=p>[]</span><span class=kd>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>input</span><span class=w>  </span><span class=kt>string</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>expect</span><span class=w> </span><span class=kt>int</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>{</span><span class=s>&#34;a&#34;</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=p>},</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>{</span><span class=s>&#34;ab&#34;</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>},</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>{</span><span class=s>&#34;abcabcbb&#34;</span><span class=p>,</span><span class=w> </span><span class=mi>3</span><span class=p>},</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>{</span><span class=s>&#34;bbbbb&#34;</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=p>},</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>{</span><span class=s>&#34;pwwkew&#34;</span><span class=p>,</span><span class=w> </span><span class=mi>3</span><span class=p>},</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=nx>i</span><span class=p>,</span><span class=w> </span><span class=nx>tt</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=k>range</span><span class=w> </span><span class=nx>tests</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>got</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nf>LengthOfLongestSubstring</span><span class=p>(</span><span class=nx>tt</span><span class=p>.</span><span class=nx>input</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=nx>got</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=nx>tt</span><span class=p>.</span><span class=nx>expect</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nx>t</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;case_%d: %s, expect: %d, got: %d&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>i</span><span class=p>,</span><span class=w> </span><span class=nx>tt</span><span class=p>.</span><span class=nx>input</span><span class=p>,</span><span class=w> </span><span class=nx>tt</span><span class=p>.</span><span class=nx>expect</span><span class=p>,</span><span class=w> </span><span class=nx>got</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// Error vs Fatal</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>测试上述测试代码，全部通过！</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>$ go <span class=nb>test</span> -run<span class=o>=</span>^TestLengthOfLongestSubstringV2$
</span></span><span class=line><span class=cl>PASS
</span></span><span class=line><span class=cl>ok      letsgo/mytest   0.006s
</span></span></code></pre></div><p>Go还提供了统计代码覆盖率的工具，可以使用代码覆盖率统计工具来统计代码的覆盖率，对于测试代码，只需要在执行<code>go test</code>时添加<code>-cover</code>参数即可。从下面的输出可以看到被测代码的覆盖率为93.8%。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>$ go <span class=nb>test</span> -run<span class=o>=</span>^TestLengthOfLongestSubstringV2$ -cover
</span></span><span class=line><span class=cl>PASS
</span></span><span class=line><span class=cl>coverage: 93.8% of statements
</span></span><span class=line><span class=cl>ok      letsgo/mytest   0.008s
</span></span></code></pre></div><p>如果想继续提高代码的覆盖率，就需要知道当前的测试用例覆盖了哪些代码，还有哪些代码没有覆盖到。Go也提供了相关的功能，只需要给<code>go test</code>命令添加<code>-coverprofile</code>参数，让<code>go test</code>生成代码覆盖信息即可。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl><span class=c1># 将代码覆盖信息输出到 c.out 文件</span>
</span></span><span class=line><span class=cl>$ go <span class=nb>test</span> -cover -coverprofile c.out -run<span class=o>=</span>^TestLengthOfLongestSubstringV2$
</span></span><span class=line><span class=cl>PASS
</span></span><span class=line><span class=cl>coverage: 93.8% of statements
</span></span><span class=line><span class=cl>ok          letsgo/mytest        0.005s
</span></span></code></pre></div><p>查看<em>c.out</em>文件，<em>c.out</em>是一个文本文件，从文件内容上看，大概可以猜到，源码行号后面的<code>0/1</code>标识代码是否被执行过。但是这个文件内容对人类不太友好，可以使用<code>go tool cover</code>将其转换成<code>html</code>查看(具体操作执行go tool cover查看帮助)。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl><span class=c1># 查看文件类型</span>
</span></span><span class=line><span class=cl>$ file c.out
</span></span><span class=line><span class=cl>c.out: ASCII text
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 查看文件内容</span>
</span></span><span class=line><span class=cl>$ cat c.out
</span></span><span class=line><span class=cl>mode: <span class=nb>set</span>
</span></span><span class=line><span class=cl>letsgo/mytest/mytest.go:4.45,5.17 <span class=m>1</span> <span class=m>1</span>
</span></span><span class=line><span class=cl>letsgo/mytest/mytest.go:5.17,7.3 <span class=m>1</span> <span class=m>0</span>
</span></span><span class=line><span class=cl>letsgo/mytest/mytest.go:10.2,14.25 <span class=m>4</span> <span class=m>1</span>
</span></span><span class=line><span class=cl>letsgo/mytest/mytest.go:14.25,15.13 <span class=m>1</span> <span class=m>1</span>
</span></span><span class=line><span class=cl>letsgo/mytest/mytest.go:15.13,18.4 <span class=m>1</span> <span class=m>1</span>
</span></span><span class=line><span class=cl>letsgo/mytest/mytest.go:19.3,19.35 <span class=m>1</span> <span class=m>1</span>
</span></span><span class=line><span class=cl>letsgo/mytest/mytest.go:19.35,23.4 <span class=m>2</span> <span class=m>1</span>
</span></span><span class=line><span class=cl>letsgo/mytest/mytest.go:25.3,25.25 <span class=m>1</span> <span class=m>1</span>
</span></span><span class=line><span class=cl>letsgo/mytest/mytest.go:27.2,27.12 <span class=m>1</span> <span class=m>1</span>
</span></span><span class=line><span class=cl>letsgo/mytest/mytest.go:30.24,31.11 <span class=m>1</span> <span class=m>1</span>
</span></span><span class=line><span class=cl>letsgo/mytest/mytest.go:31.11,33.3 <span class=m>1</span> <span class=m>1</span>
</span></span><span class=line><span class=cl>letsgo/mytest/mytest.go:34.2,34.10 <span class=m>1</span> <span class=m>1</span>
</span></span></code></pre></div><p>使用<code>go tool cover</code>就可以发现源码中的如下的<code>if</code>内的代码没有被执行，因此只需要构造一个空字符串（长度为0）作为测试用例，即可使代码覆盖率达到100%。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Go data-lang=Go><span class=line><span class=cl><span class=c1>// mytest/mytest_test.go</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>func</span><span class=w> </span><span class=nf>LengthOfLongestSubstring</span><span class=p>(</span><span class=nx>s</span><span class=w> </span><span class=kt>string</span><span class=p>)</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nb>len</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=mi>0</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// ......</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>那么问题来了：</p><ul><li>实际项目中测试几乎做不到100%，如何提高代码的测试用例？</li><li>代码覆盖率很高甚至达到了100%就能保证代码没有bug吗？</li></ul><p>针对第二个问题，答案是<strong>否定</strong>的。举个很简单的例子(如下)，只要调用这个函数，代码的覆盖率就是100%，但是这个代码明显存在除0错误。虽然代码覆盖率达到了100%不能保证代码没有bug，但是代码覆盖率仍然是越高越好。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Go data-lang=Go><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>MyDiv</span><span class=p>(</span><span class=nx>a</span><span class=p>,</span><span class=w> </span><span class=nx>b</span><span class=p>,</span><span class=w> </span><span class=nx>c</span><span class=w> </span><span class=kt>int</span><span class=p>)</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=nx>a</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=p>(</span><span class=nx>b</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=nx>c</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>有没有方法能提高代码覆盖率，发现移植代码的bug呢？答案是<strong>肯定</strong>的，那就是fuzzing！</p><h5 id=fuzzxxx>FuzzXxx<a hidden class=anchor aria-hidden=true href=#fuzzxxx>#</a></h5><p>**用途：**用于挖掘深藏的bug。</p><p><strong>思想</strong>：变异+反馈（物竞天择，适者生存）；</p><p><strong>原理</strong>：将被测对象看作一个有输入和输出的系统，对系统输入不同的测试用例，统计系统内部的代码执行情况和输出，并将有意义的输入作为种子进行变异再作为输入，不断重复。</p><p><img alt=fuzzing loading=lazy src=/images/posts/go-testing/fuzzing.png>
<img alt=fuzzing loading=lazy src=/images/posts/go-testing/afl_fuzz.gif></p><p>模糊测试的流行得益于模糊测试工具<a href=https://lcamtuf.coredump.cx/afl/>AFL</a>，Go对fuzz的原生支持是从Go1.18开始的。使用Go的Fuzz并不难，只要准备初始测试用例即可。下面举个例子：</p><p>被测代码如下，还是求一个字符串的最长字串的实现，和前面的代码相比，这里调用了一个<code>bugInHere</code>函数，这个函数里面隐藏了一个bug。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Go data-lang=Go><span class=line><span class=cl><span class=c1>// fuzz/fuzz.go</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kn>package</span><span class=w> </span><span class=nx>fuzz</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>func</span><span class=w> </span><span class=nf>bugInHere</span><span class=p>(</span><span class=nx>s</span><span class=w> </span><span class=kt>string</span><span class=p>)</span><span class=w> </span><span class=kt>string</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nb>len</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span><span class=w> </span><span class=p>&gt;</span><span class=w> </span><span class=mi>8</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=nx>s</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=sc>&#39;p&#39;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=nx>s</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=sc>&#39;a&#39;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>if</span><span class=w> </span><span class=nx>s</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=sc>&#39;n&#39;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=k>if</span><span class=w> </span><span class=nx>s</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=sc>&#39;i&#39;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=k>if</span><span class=w> </span><span class=nx>s</span><span class=p>[</span><span class=mi>4</span><span class=p>]</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=sc>&#39;c&#39;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=k>if</span><span class=w> </span><span class=nx>s</span><span class=p>[</span><span class=mi>5</span><span class=p>]</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=sc>&#39; &#39;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                </span><span class=k>if</span><span class=w> </span><span class=nx>s</span><span class=p>[</span><span class=mi>6</span><span class=p>]</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=sc>&#39;b&#39;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                    </span><span class=k>if</span><span class=w> </span><span class=nx>s</span><span class=p>[</span><span class=mi>7</span><span class=p>]</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=sc>&#39;u&#39;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                        </span><span class=k>if</span><span class=w> </span><span class=nx>s</span><span class=p>[</span><span class=mi>8</span><span class=p>]</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=sc>&#39;g&#39;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                            </span><span class=k>return</span><span class=w> </span><span class=nx>s</span><span class=p>[:</span><span class=mi>10</span><span class=p>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=nx>s</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>func</span><span class=w> </span><span class=nf>LengthOfLongestSubstring</span><span class=p>(</span><span class=nx>s</span><span class=w> </span><span class=kt>string</span><span class=p>)</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nb>len</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=mi>0</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>s</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nf>bugInHere</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span><span class=w> </span><span class=c1>// panic</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 哈希集合，记录每个字符是否出现过</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>m</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>map</span><span class=p>[</span><span class=kt>byte</span><span class=p>]</span><span class=kt>int</span><span class=p>{}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>n</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nb>len</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>rk</span><span class=p>,</span><span class=w> </span><span class=nx>ans</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=o>-</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=p>&lt;</span><span class=w> </span><span class=nx>n</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=o>++</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// 左指针向右移动一格，移除一个字符</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nb>delete</span><span class=p>(</span><span class=nx>m</span><span class=p>,</span><span class=w> </span><span class=nx>s</span><span class=p>[</span><span class=nx>i</span><span class=o>-</span><span class=mi>1</span><span class=p>])</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=nx>rk</span><span class=o>+</span><span class=mi>1</span><span class=w> </span><span class=p>&lt;</span><span class=w> </span><span class=nx>n</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=nx>m</span><span class=p>[</span><span class=nx>s</span><span class=p>[</span><span class=nx>rk</span><span class=o>+</span><span class=mi>1</span><span class=p>]]</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// 不断地移动右指针</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nx>m</span><span class=p>[</span><span class=nx>s</span><span class=p>[</span><span class=nx>rk</span><span class=o>+</span><span class=mi>1</span><span class=p>]]</span><span class=o>++</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nx>rk</span><span class=o>++</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 第 i 到 rk 个字符是一个极长的无重复字符子串</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>ans</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nb>max</span><span class=p>(</span><span class=nx>ans</span><span class=p>,</span><span class=w> </span><span class=nx>rk</span><span class=o>-</span><span class=nx>i</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=nx>ans</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>func</span><span class=w> </span><span class=nb>max</span><span class=p>(</span><span class=nx>x</span><span class=p>,</span><span class=w> </span><span class=nx>y</span><span class=w> </span><span class=kt>int</span><span class=p>)</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nx>x</span><span class=w> </span><span class=p>&lt;</span><span class=w> </span><span class=nx>y</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=nx>y</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=nx>x</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>下面尝试fuzz上面的代码，fuzz测试代码如下，fuzz测试代码很简单，只需要两部即可：</p><ol><li>创建初始化测试用例并添加到<code>testing.F</code>中；</li><li>调用<code>f.Fuzz</code>开始fuzz。</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-Go data-lang=Go><span class=line><span class=cl><span class=c1>// fuzz/fuzz_test.go</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>func</span><span class=w> </span><span class=nf>FuzzLengthOfLongestSubstring</span><span class=p>(</span><span class=nx>f</span><span class=w> </span><span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>F</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 创建初始测试用例（种子）</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>tests</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=p>[]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;&#34;</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=nx>_</span><span class=p>,</span><span class=w> </span><span class=nx>ts</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=k>range</span><span class=w> </span><span class=nx>tests</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>f</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=nx>ts</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 开始 fuzz</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>f</span><span class=p>.</span><span class=nf>Fuzz</span><span class=p>(</span><span class=kd>func</span><span class=p>(</span><span class=nx>t</span><span class=w> </span><span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>T</span><span class=p>,</span><span class=w> </span><span class=nx>a</span><span class=w> </span><span class=kt>string</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nf>LengthOfLongestSubstring</span><span class=p>(</span><span class=nx>a</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>})</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>执行下面的命令开始fuzz，从输出可以看到程序运行了32s触发了程序的bug，导致panic了。触发bug的输入在当前目录下的<code>testdata/fuzz/FuzzLenthOfLongestSubstring</code>目录下。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl><span class=c1># 执行fuzz命令</span>
</span></span><span class=line><span class=cl>$ go <span class=nb>test</span> -fuzz<span class=o>=</span>^FuzzLengthOfLongestSubstring$ -v
</span></span><span class=line><span class=cl><span class=o>===</span> RUN   <span class=nv>FuzzLengthOfLongestSubstringV2</span>
</span></span><span class=line><span class=cl><span class=o>===</span> RUN   FuzzLengthOfLongestSubstringV2/seed#0
</span></span><span class=line><span class=cl><span class=o>===</span> RUN   FuzzLengthOfLongestSubstringV2/seed#1
</span></span><span class=line><span class=cl><span class=o>===</span> RUN   FuzzLengthOfLongestSubstringV2/seed#2
</span></span><span class=line><span class=cl><span class=o>===</span> RUN   FuzzLengthOfLongestSubstringV2/seed#3
</span></span><span class=line><span class=cl><span class=o>===</span> RUN   FuzzLengthOfLongestSubstringV2/seed#4
</span></span><span class=line><span class=cl><span class=o>===</span> RUN   FuzzLengthOfLongestSubstringV2/seed#5
</span></span><span class=line><span class=cl>--- PASS: FuzzLengthOfLongestSubstringV2 <span class=o>(</span>0.00s<span class=o>)</span>
</span></span><span class=line><span class=cl>    --- PASS: FuzzLengthOfLongestSubstringV2/seed#0 <span class=o>(</span>0.00s<span class=o>)</span>
</span></span><span class=line><span class=cl>    --- PASS: FuzzLengthOfLongestSubstringV2/seed#1 <span class=o>(</span>0.00s<span class=o>)</span>
</span></span><span class=line><span class=cl>    --- PASS: FuzzLengthOfLongestSubstringV2/seed#2 <span class=o>(</span>0.00s<span class=o>)</span>
</span></span><span class=line><span class=cl>    --- PASS: FuzzLengthOfLongestSubstringV2/seed#3 <span class=o>(</span>0.00s<span class=o>)</span>
</span></span><span class=line><span class=cl>    --- PASS: FuzzLengthOfLongestSubstringV2/seed#4 <span class=o>(</span>0.00s<span class=o>)</span>
</span></span><span class=line><span class=cl>    --- PASS: FuzzLengthOfLongestSubstringV2/seed#5 <span class=o>(</span>0.00s<span class=o>)</span>
</span></span><span class=line><span class=cl><span class=o>===</span> RUN   FuzzLengthOfLongestSubstring
</span></span><span class=line><span class=cl>fuzz: elapsed: 0s, gathering baseline coverage: 0/22 completed
</span></span><span class=line><span class=cl>fuzz: elapsed: 0s, gathering baseline coverage: 22/22 completed, now fuzzing with <span class=m>8</span> workers
</span></span><span class=line><span class=cl>fuzz: elapsed: 3s, execs: <span class=m>220261</span> <span class=o>(</span>73409/sec<span class=o>)</span>, new interesting: <span class=m>0</span> <span class=o>(</span>total: 22<span class=o>)</span>
</span></span><span class=line><span class=cl>fuzz: elapsed: 6s, execs: <span class=m>442482</span> <span class=o>(</span>74025/sec<span class=o>)</span>, new interesting: <span class=m>0</span> <span class=o>(</span>total: 22<span class=o>)</span>
</span></span><span class=line><span class=cl>fuzz: elapsed: 9s, execs: <span class=m>675241</span> <span class=o>(</span>77628/sec<span class=o>)</span>, new interesting: <span class=m>0</span> <span class=o>(</span>total: 22<span class=o>)</span>
</span></span><span class=line><span class=cl>fuzz: elapsed: 12s, execs: <span class=m>893474</span> <span class=o>(</span>72688/sec<span class=o>)</span>, new interesting: <span class=m>0</span> <span class=o>(</span>total: 22<span class=o>)</span>
</span></span><span class=line><span class=cl>fuzz: elapsed: 15s, execs: <span class=m>1127763</span> <span class=o>(</span>78167/sec<span class=o>)</span>, new interesting: <span class=m>0</span> <span class=o>(</span>total: 22<span class=o>)</span>
</span></span><span class=line><span class=cl>fuzz: elapsed: 18s, execs: <span class=m>1364191</span> <span class=o>(</span>78804/sec<span class=o>)</span>, new interesting: <span class=m>0</span> <span class=o>(</span>total: 22<span class=o>)</span>
</span></span><span class=line><span class=cl>fuzz: elapsed: 21s, execs: <span class=m>1581999</span> <span class=o>(</span>72609/sec<span class=o>)</span>, new interesting: <span class=m>0</span> <span class=o>(</span>total: 22<span class=o>)</span>
</span></span><span class=line><span class=cl>fuzz: elapsed: 24s, execs: <span class=m>1829063</span> <span class=o>(</span>82274/sec<span class=o>)</span>, new interesting: <span class=m>0</span> <span class=o>(</span>total: 22<span class=o>)</span>
</span></span><span class=line><span class=cl>fuzz: elapsed: 27s, execs: <span class=m>2057236</span> <span class=o>(</span>76138/sec<span class=o>)</span>, new interesting: <span class=m>0</span> <span class=o>(</span>total: 22<span class=o>)</span>
</span></span><span class=line><span class=cl>fuzz: elapsed: 30s, execs: <span class=m>2295217</span> <span class=o>(</span>79327/sec<span class=o>)</span>, new interesting: <span class=m>0</span> <span class=o>(</span>total: 22<span class=o>)</span>
</span></span><span class=line><span class=cl>fuzz: elapsed: 32s, execs: <span class=m>2446099</span> <span class=o>(</span>68996/sec<span class=o>)</span>, new interesting: <span class=m>0</span> <span class=o>(</span>total: 22<span class=o>)</span>
</span></span><span class=line><span class=cl>--- FAIL: FuzzLengthOfLongestSubstring <span class=o>(</span>32.19s<span class=o>)</span>
</span></span><span class=line><span class=cl>    --- FAIL: FuzzLengthOfLongestSubstring <span class=o>(</span>0.00s<span class=o>)</span>
</span></span><span class=line><span class=cl>        testing.go:1504: panic: runtime error: slice bounds out of range <span class=o>[</span>:10<span class=o>]</span> with length <span class=m>9</span>
</span></span><span class=line><span class=cl>            goroutine <span class=m>314427</span> <span class=o>[</span>running<span class=o>]</span>:
</span></span><span class=line><span class=cl>            runtime/debug.Stack<span class=o>()</span>
</span></span><span class=line><span class=cl>                /usr/local/go/src/runtime/debug/stack.go:24 +0x9b
</span></span><span class=line><span class=cl>            testing.tRunner.func1<span class=o>()</span>
</span></span><span class=line><span class=cl>                /usr/local/go/src/testing/testing.go:1504 +0x1ee
</span></span><span class=line><span class=cl>            panic<span class=o>({</span>0x5e8300?, 0xc00001b9e0?<span class=o>})</span>
</span></span><span class=line><span class=cl>                /usr/local/go/src/runtime/panic.go:914 +0x21f
</span></span><span class=line><span class=cl>            letsgo/fuzz.bugInHere<span class=o>(</span>...<span class=o>)</span>
</span></span><span class=line><span class=cl>                /home/nop/happycoding/wtfs/letsgo/fuzz/fuzz.go:15
</span></span><span class=line><span class=cl>            letsgo/fuzz.LengthOfLongestSubstring<span class=o>({</span>0xc0091ae3c5, 0x9<span class=o>})</span>
</span></span><span class=line><span class=cl>                /home/nop/happycoding/wtfs/letsgo/fuzz/fuzz.go:36 +0x885
</span></span><span class=line><span class=cl>            letsgo/fuzz.FuzzLengthOfLongestSubstring.func1<span class=o>(</span>0x0?, <span class=o>{</span>0xc0091ae3c5?, 0x0?<span class=o>})</span>
</span></span><span class=line><span class=cl>                /home/nop/happycoding/wtfs/letsgo/fuzz/fuzz_test.go:38 +0x3b
</span></span><span class=line><span class=cl>            reflect.Value.call<span class=o>({</span>0x5c37c0?, 0x607ad8?, 0x13?<span class=o>}</span>, <span class=o>{</span>0x5f83fc, 0x4<span class=o>}</span>, <span class=o>{</span>0xc0091b8150, 0x2, 0x2?<span class=o>})</span>
</span></span><span class=line><span class=cl>                /usr/local/go/src/reflect/value.go:596 +0xce7
</span></span><span class=line><span class=cl>            reflect.Value.Call<span class=o>({</span>0x5c37c0?, 0x607ad8?, 0x72f7c0?<span class=o>}</span>, <span class=o>{</span>0xc0091b8150?, 0x5f7a00?, 0x52220d?<span class=o>})</span>
</span></span><span class=line><span class=cl>                /usr/local/go/src/reflect/value.go:380 +0xb9
</span></span><span class=line><span class=cl>            testing.<span class=o>(</span>*F<span class=o>)</span>.Fuzz.func1.1<span class=o>(</span>0x406420?<span class=o>)</span>
</span></span><span class=line><span class=cl>                /usr/local/go/src/testing/fuzz.go:335 +0x347
</span></span><span class=line><span class=cl>            testing.tRunner<span class=o>(</span>0xc0091b5520, 0xc0091ab3b0<span class=o>)</span>
</span></span><span class=line><span class=cl>                /usr/local/go/src/testing/testing.go:1595 +0xff
</span></span><span class=line><span class=cl>            created by testing.<span class=o>(</span>*F<span class=o>)</span>.Fuzz.func1 in goroutine <span class=m>18</span>
</span></span><span class=line><span class=cl>                /usr/local/go/src/testing/fuzz.go:322 +0x597
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    Failing input written to testdata/fuzz/FuzzLengthOfLongestSubstring/87820115886ac14a
</span></span><span class=line><span class=cl>    To re-run:
</span></span><span class=line><span class=cl>    go <span class=nb>test</span> -run<span class=o>=</span>FuzzLengthOfLongestSubstring/87820115886ac14a
</span></span><span class=line><span class=cl><span class=o>===</span> NAME  
</span></span><span class=line><span class=cl>FAIL
</span></span><span class=line><span class=cl><span class=nb>exit</span> status <span class=m>1</span>
</span></span><span class=line><span class=cl>FAIL    letsgo/fuzz     32.208s
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 触发bug的测试用例在 testdata/fuzz/FuzzLengthOfLongestSubstring 目录下。</span>
</span></span><span class=line><span class=cl>$ tree
</span></span><span class=line><span class=cl>.
</span></span><span class=line><span class=cl>├── fuzz.go
</span></span><span class=line><span class=cl>├── fuzz_test.go
</span></span><span class=line><span class=cl>└── testdata
</span></span><span class=line><span class=cl>    └── fuzz
</span></span><span class=line><span class=cl>        └── FuzzLengthOfLongestSubstring
</span></span><span class=line><span class=cl>            └── 87820115886ac14a
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 触发程序bug的测试用例            </span>
</span></span><span class=line><span class=cl>$ cat testdata/fuzz/FuzzLengthOfLongestSubstring/87820115886ac14a
</span></span><span class=line><span class=cl>go <span class=nb>test</span> fuzz v1
</span></span><span class=line><span class=cl>string<span class=o>(</span><span class=s2>&#34;panic bug&#34;</span><span class=o>)</span>
</span></span></code></pre></div><p>更多细节见：</p><ul><li>testing包文档；</li><li><a href=https://go.dev/doc/tutorial/fuzz>Tutorial: Getting started with fuzzing</a></li></ul><h5 id=benchmarkxxx>BenchmarkXxx<a hidden class=anchor aria-hidden=true href=#benchmarkxxx>#</a></h5><p>**用途：**测试代码的性能（执行效率，内存分配、内存使用情况等）。</p><ul><li><strong>Inline vs Noinline；</strong></li></ul><p>用benchmark来对比一下inline和noinline的性能差距有多大。默认情况下<code>go build</code>在编译源码时会对源码进行优化，其中一项就是将比较简单的函数inline，为了禁止函数编译器对函数做inline优化，可以使用*<code>//go:noinline</code>**。*</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Go data-lang=Go><span class=line><span class=cl><span class=c1>// fuzz/fuzz_test.go</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>func</span><span class=w> </span><span class=nf>InlineMax</span><span class=p>(</span><span class=nx>a</span><span class=p>,</span><span class=w> </span><span class=nx>b</span><span class=w> </span><span class=kt>int</span><span class=p>)</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nx>a</span><span class=w> </span><span class=p>&gt;</span><span class=w> </span><span class=nx>b</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=nx>a</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=nx>b</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>//go:noinline</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>func</span><span class=w> </span><span class=nf>NonInlineMax</span><span class=p>(</span><span class=nx>a</span><span class=p>,</span><span class=w> </span><span class=nx>b</span><span class=w> </span><span class=kt>int</span><span class=p>)</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nx>a</span><span class=w> </span><span class=p>&gt;</span><span class=w> </span><span class=nx>b</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=nx>a</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=nx>b</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>对上面两个函数做性能分析，测试代码如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Go data-lang=Go><span class=line><span class=cl><span class=c1>// bench/bench_test.go</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>var</span><span class=w> </span><span class=nx>Result</span><span class=w> </span><span class=kt>int</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>func</span><span class=w> </span><span class=nf>BenchmarkMaxInline</span><span class=p>(</span><span class=nx>b</span><span class=w> </span><span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>B</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>var</span><span class=w> </span><span class=nx>r</span><span class=w> </span><span class=kt>int</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=p>&lt;</span><span class=w> </span><span class=nx>b</span><span class=p>.</span><span class=nx>N</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=o>++</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>r</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nf>InlineMax</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>Result</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>r</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>func</span><span class=w> </span><span class=nf>BenchmarkMaxNonInline</span><span class=p>(</span><span class=nx>b</span><span class=w> </span><span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>B</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>var</span><span class=w> </span><span class=nx>r</span><span class=w> </span><span class=kt>int</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=p>&lt;</span><span class=w> </span><span class=nx>b</span><span class=p>.</span><span class=nx>N</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=o>++</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>r</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nf>NonInlineMax</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>Result</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>r</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>执行上面的测试代码，输出了每个测试函数1s时间的执行情况：<code>BenchmarkMaxInline-8</code>执行了1000000000次，平均每次迭代耗时0.7953 ns，<code>BenchmarkMaxNonInline-8</code>执行了447639264次，平均每次迭代耗时3.841 ns。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>$ go <span class=nb>test</span> -bench<span class=o>=</span>^BenchmarkMax -run<span class=o>=</span><span class=s2>&#34;&#34;</span>
</span></span><span class=line><span class=cl>goos: linux
</span></span><span class=line><span class=cl>goarch: amd64
</span></span><span class=line><span class=cl>pkg: letsgo/bench
</span></span><span class=line><span class=cl>cpu: 12th Gen Intel<span class=o>(</span>R<span class=o>)</span> Core<span class=o>(</span>TM<span class=o>)</span> i7-12700H
</span></span><span class=line><span class=cl>BenchmarkMaxInline-8            <span class=m>1000000000</span>               0.7953 ns/op
</span></span><span class=line><span class=cl>BenchmarkMaxNonInline-8         <span class=m>447639264</span>                3.841 ns/op
</span></span><span class=line><span class=cl>PASS
</span></span><span class=line><span class=cl>ok      letsgo/bench    2.939s
</span></span></code></pre></div><ul><li><strong>Concat string；</strong></li></ul><p>下面实现了三种拼接字符串的方法，具体实现方式分别为：使用字符串的<code>+</code>操作符拼接、使用<code>fmt.Sprintf</code>拼接和使用<code>strings.Join</code>拼接。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Go data-lang=Go><span class=line><span class=cl><span class=c1>// bench/bench.go</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>func</span><span class=w> </span><span class=nf>ConcatStringByOperator</span><span class=p>(</span><span class=nx>sl</span><span class=w> </span><span class=p>[]</span><span class=kt>string</span><span class=p>)</span><span class=w> </span><span class=kt>string</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>var</span><span class=w> </span><span class=nx>s</span><span class=w> </span><span class=kt>string</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=nx>_</span><span class=p>,</span><span class=w> </span><span class=nx>v</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=k>range</span><span class=w> </span><span class=nx>sl</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>s</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=nx>v</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=nx>s</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>func</span><span class=w> </span><span class=nf>ConcatStringBySprintf</span><span class=p>(</span><span class=nx>sl</span><span class=w> </span><span class=p>[]</span><span class=kt>string</span><span class=p>)</span><span class=w> </span><span class=kt>string</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>var</span><span class=w> </span><span class=nx>s</span><span class=w> </span><span class=kt>string</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=nx>_</span><span class=p>,</span><span class=w> </span><span class=nx>v</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=k>range</span><span class=w> </span><span class=nx>sl</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>s</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=s>&#34;%s%s&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>s</span><span class=p>,</span><span class=w> </span><span class=nx>v</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=nx>s</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>func</span><span class=w> </span><span class=nf>ConcatStringByJoin</span><span class=p>(</span><span class=nx>sl</span><span class=w> </span><span class=p>[]</span><span class=kt>string</span><span class=p>)</span><span class=w> </span><span class=kt>string</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=nx>strings</span><span class=p>.</span><span class=nf>Join</span><span class=p>(</span><span class=nx>sl</span><span class=p>,</span><span class=w> </span><span class=s>&#34;&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>测试代码如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Go data-lang=Go><span class=line><span class=cl><span class=c1>// bench/bench_test.go</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>var</span><span class=w> </span><span class=nx>sl</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=p>[]</span><span class=kt>string</span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=s>&#34;Rob Pike &#34;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=s>&#34;Robert Griesemer &#34;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=s>&#34;Ken Thompson &#34;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>func</span><span class=w> </span><span class=nf>BenchmarkConcatStringByOperator</span><span class=p>(</span><span class=nx>b</span><span class=w> </span><span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>B</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=nx>n</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=nx>n</span><span class=w> </span><span class=p>&lt;</span><span class=w> </span><span class=nx>b</span><span class=p>.</span><span class=nx>N</span><span class=p>;</span><span class=w> </span><span class=nx>n</span><span class=o>++</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nf>ConcatStringByOperator</span><span class=p>(</span><span class=nx>sl</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>func</span><span class=w> </span><span class=nf>BenchmarkConcatStringBySprintf</span><span class=p>(</span><span class=nx>b</span><span class=w> </span><span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>B</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=nx>n</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=nx>n</span><span class=w> </span><span class=p>&lt;</span><span class=w> </span><span class=nx>b</span><span class=p>.</span><span class=nx>N</span><span class=p>;</span><span class=w> </span><span class=nx>n</span><span class=o>++</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nf>ConcatStringBySprintf</span><span class=p>(</span><span class=nx>sl</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>func</span><span class=w> </span><span class=nf>BenchmarkConcatStringByJoin</span><span class=p>(</span><span class=nx>b</span><span class=w> </span><span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>B</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=nx>n</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=nx>n</span><span class=w> </span><span class=p>&lt;</span><span class=w> </span><span class=nx>b</span><span class=p>.</span><span class=nx>N</span><span class=p>;</span><span class=w> </span><span class=nx>n</span><span class=o>++</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nf>ConcatStringByJoin</span><span class=p>(</span><span class=nx>sl</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>执行上面的测试代码，上面的字符串的拼接需额外的内存，可以在<code>go test</code>命令后添加<code>-benchmem</code>来查看内存分配情况。具体输出如下，以<code>BenchmarkConcatStringByOperator-8</code>输出为例：</p><p>1s内迭代了4614390次，平均每次迭代耗时240.6 ns，平均每次迭代申请了80bytes，平均每次迭代申请了2次内存。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>$ go <span class=nb>test</span> -run<span class=o>=</span><span class=s2>&#34;&#34;</span> -bench<span class=o>=</span>^BenchmarkConcat -benchmem
</span></span><span class=line><span class=cl>goos: linux
</span></span><span class=line><span class=cl>goarch: amd64
</span></span><span class=line><span class=cl>pkg: letsgo/bench
</span></span><span class=line><span class=cl>cpu: 12th Gen Intel<span class=o>(</span>R<span class=o>)</span> Core<span class=o>(</span>TM<span class=o>)</span> i7-12700H
</span></span><span class=line><span class=cl>BenchmarkConcatStringByOperator-8        <span class=m>4614390</span>               240.6 ns/op            <span class=m>80</span> B/op          <span class=m>2</span> allocs/op
</span></span><span class=line><span class=cl>BenchmarkConcatStringBySprintf-8         <span class=m>1096496</span>              <span class=m>1024</span> ns/op             <span class=m>176</span> B/op          <span class=m>8</span> allocs/op
</span></span><span class=line><span class=cl>BenchmarkConcatStringByJoin-8            <span class=m>7350830</span>               152.6 ns/op            <span class=m>48</span> B/op          <span class=m>1</span> allocs/op
</span></span><span class=line><span class=cl>PASS
</span></span><span class=line><span class=cl>ok      letsgo/bench    4.872s
</span></span></code></pre></div><ul><li><strong>Start/Stop timer；</strong></li></ul><p>go test默认给每个Benchmark函数分配1s时间，但是有些情况下需要先初始化，然后再进行测试，如果初始化比较耗时，可能会影响基准测试的测试结果。解决方法就是在执行耗时的操作之前停止计时，等到耗时操作执行完之后再继续计时。测试代码如下，用Init模拟一个比较耗时的操作。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Go data-lang=Go><span class=line><span class=cl><span class=c1>// bench/bench_test.go</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>func</span><span class=w> </span><span class=nf>Init</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>500</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=nx>time</span><span class=p>.</span><span class=nx>Millisecond</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>func</span><span class=w> </span><span class=nf>BenchmarkWithoutInit</span><span class=p>(</span><span class=nx>b</span><span class=w> </span><span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>B</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=nx>n</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=nx>n</span><span class=w> </span><span class=p>&lt;</span><span class=w> </span><span class=nx>b</span><span class=p>.</span><span class=nx>N</span><span class=p>;</span><span class=w> </span><span class=nx>n</span><span class=o>++</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nf>ConcatStringByJoin</span><span class=p>(</span><span class=nx>sl</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>func</span><span class=w> </span><span class=nf>BenchmarkWithInitV1</span><span class=p>(</span><span class=nx>b</span><span class=w> </span><span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>B</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nf>Init</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=nx>n</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=nx>n</span><span class=w> </span><span class=p>&lt;</span><span class=w> </span><span class=nx>b</span><span class=p>.</span><span class=nx>N</span><span class=p>;</span><span class=w> </span><span class=nx>n</span><span class=o>++</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nf>ConcatStringByJoin</span><span class=p>(</span><span class=nx>sl</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>func</span><span class=w> </span><span class=nf>BenchmarkWithInitV2</span><span class=p>(</span><span class=nx>b</span><span class=w> </span><span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>B</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>b</span><span class=p>.</span><span class=nf>StopTimer</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nf>Init</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>b</span><span class=p>.</span><span class=nf>StartTimer</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// b.ResetTimer()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=nx>n</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=nx>n</span><span class=w> </span><span class=p>&lt;</span><span class=w> </span><span class=nx>b</span><span class=p>.</span><span class=nx>N</span><span class=p>;</span><span class=w> </span><span class=nx>n</span><span class=o>++</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nf>ConcatStringByJoin</span><span class=p>(</span><span class=nx>sl</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>测试结果如下，可以看到<code>BenchmarkWithoutInit-8</code>和<code>BenchmarkWithInitV2-8</code>的平均每个迭代执行时间差不多。而未使用<code>StopTimer</code>和<code>StartTimer</code>的<code>BenchmarkWithInitV1-8 </code>的平均每个迭代的执行差不多时间是<code>BenchmarkWithInitV2-8</code>的2倍。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>$ go <span class=nb>test</span> -run<span class=o>=</span><span class=s2>&#34;&#34;</span> -bench<span class=o>=</span>^BenchmarkWith
</span></span><span class=line><span class=cl>goos: linux
</span></span><span class=line><span class=cl>goarch: amd64
</span></span><span class=line><span class=cl>pkg: letsgo/bench
</span></span><span class=line><span class=cl>cpu: 12th Gen Intel<span class=o>(</span>R<span class=o>)</span> Core<span class=o>(</span>TM<span class=o>)</span> i7-12700H
</span></span><span class=line><span class=cl>BenchmarkWithoutInit-8           <span class=m>8317146</span>               154.0 ns/op
</span></span><span class=line><span class=cl>BenchmarkWithInitV1-8            <span class=m>4181710</span>               272.9 ns/op
</span></span><span class=line><span class=cl>BenchmarkWithInitV2-8            <span class=m>7411749</span>               153.3 ns/op
</span></span><span class=line><span class=cl>PASS
</span></span><span class=line><span class=cl>ok      letsgo/bench    18.368s
</span></span></code></pre></div><h5 id=examplexxx>ExampleXxx<a hidden class=anchor aria-hidden=true href=#examplexxx>#</a></h5><p>用于检测被测代码的输出是否符合预期，重点关注输出（<strong>仅仅指stdout</strong>）。</p><p>测试代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Go data-lang=Go><span class=line><span class=cl><span class=c1>// example/example.go</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kn>package</span><span class=w> </span><span class=nx>example</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>func</span><span class=w> </span><span class=nf>HelloWrold</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;hello world&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>func</span><span class=w> </span><span class=nf>HelloWorld2</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Fprintf</span><span class=p>(</span><span class=nx>os</span><span class=p>.</span><span class=nx>Stderr</span><span class=p>,</span><span class=w> </span><span class=s>&#34;hello world&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>测试代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Go data-lang=Go><span class=line><span class=cl><span class=c1>// example/example_test.go</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kn>package</span><span class=w> </span><span class=nx>example_test</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kn>import</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=s>&#34;letsgo/example&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>func</span><span class=w> </span><span class=nf>ExampleHelloWorld</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>example</span><span class=p>.</span><span class=nf>HelloWorld</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Output: hello world</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>func</span><span class=w> </span><span class=nf>ExampleHelloWorld2</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>example</span><span class=p>.</span><span class=nf>HelloWorld2</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Output:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>执行上面的测试代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>$ go <span class=nb>test</span> -run<span class=o>=</span>^Example -v                                          ✔ ╱ nop@nop-vm  11:06:48 <span class=nv>上午</span> 
</span></span><span class=line><span class=cl><span class=o>===</span> RUN   ExampleHelloWorld
</span></span><span class=line><span class=cl>--- PASS: ExampleHelloWorld <span class=o>(</span>0.00s<span class=o>)</span>
</span></span><span class=line><span class=cl><span class=o>===</span> RUN   ExampleHelloWorld2
</span></span><span class=line><span class=cl>hello world--- PASS: ExampleHelloWorld2 <span class=o>(</span>0.00s<span class=o>)</span>
</span></span><span class=line><span class=cl><span class=o>===</span> RUN   ExampleMap
</span></span><span class=line><span class=cl>--- PASS: ExampleMap <span class=o>(</span>0.00s<span class=o>)</span>
</span></span><span class=line><span class=cl>PASS
</span></span><span class=line><span class=cl>ok      letsgo/example  0.007s
</span></span></code></pre></div><p>另外，如果输出结果顺序是不确定的，可以用<code>Unordered output</code>，如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Go data-lang=Go><span class=line><span class=cl><span class=c1>// example/example.go</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>func</span><span class=w> </span><span class=nf>PrintMap</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>colors</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>string</span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=s>&#34;red&#34;</span><span class=p>:</span><span class=w>   </span><span class=s>&#34;红&#34;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=s>&#34;green&#34;</span><span class=p>:</span><span class=w> </span><span class=s>&#34;绿&#34;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=s>&#34;blue&#34;</span><span class=p>:</span><span class=w>  </span><span class=s>&#34;蓝&#34;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=nx>k</span><span class=p>,</span><span class=w> </span><span class=nx>v</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=k>range</span><span class=w> </span><span class=nx>colors</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>k</span><span class=p>,</span><span class=w> </span><span class=nx>v</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// example/example_test.go</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kn>package</span><span class=w> </span><span class=nx>example_test</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>func</span><span class=w> </span><span class=nf>ExamplePrintMap</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>example</span><span class=p>.</span><span class=nf>PrintMap</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Unordered output:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// red 红</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// blue 蓝</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// green 绿</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h4 id=其他>其他<a hidden class=anchor aria-hidden=true href=#其他>#</a></h4><h5 id=testdata>testdata<a hidden class=anchor aria-hidden=true href=#testdata>#</a></h5><p>testdata是一个特殊的目录名，go在编译源码时会自动忽略这个文件中的文件（包括<code>*.go</code>文件），<code>testdata</code>一般用于存放测试需要的数据或者生成的数据。</p><h3 id=go-test><code>go test</code><a hidden class=anchor aria-hidden=true href=#go-test>#</a></h3><p>执行<code>go test</code>命令时，<code>go test</code>的处理步骤如下：</p><ol><li>生成测试程序的主函数（我们编写的测代码其实是这个测试主函数需要的数据）；</li><li>调用<code>go build</code>编译测试程序，生成可执行文件；</li><li>调用可执行文件，执行测试函数；</li><li>删除步骤2生成的可执行文件；</li></ol><h4 id=go-test用法>go test用法<a hidden class=anchor aria-hidden=true href=#go-test用法>#</a></h4><p><code>go test</code>命令的用法，可以使用<code>go help test</code>命令查看。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Go data-lang=Go><span class=line><span class=cl><span class=err>$</span><span class=w> </span><span class=k>go</span><span class=w> </span><span class=nx>help</span><span class=w> </span><span class=nx>test</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nx>usage</span><span class=p>:</span><span class=w> </span><span class=k>go</span><span class=w> </span><span class=nx>test</span><span class=w> </span><span class=p>[</span><span class=nx>build</span><span class=o>/</span><span class=nx>test</span><span class=w> </span><span class=nx>flags</span><span class=p>]</span><span class=w> </span><span class=p>[</span><span class=nx>packages</span><span class=p>]</span><span class=w> </span><span class=p>[</span><span class=nx>build</span><span class=o>/</span><span class=nx>test</span><span class=w> </span><span class=nx>flags</span><span class=w> </span><span class=o>&amp;</span><span class=w> </span><span class=nx>test</span><span class=w> </span><span class=nx>binary</span><span class=w> </span><span class=nx>flags</span><span class=p>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>......</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nx>The</span><span class=w> </span><span class=nx>test</span><span class=w> </span><span class=nx>binary</span><span class=w> </span><span class=nx>also</span><span class=w> </span><span class=nx>accepts</span><span class=w> </span><span class=nx>flags</span><span class=w> </span><span class=nx>that</span><span class=w> </span><span class=nx>control</span><span class=w> </span><span class=nx>execution</span><span class=w> </span><span class=nx>of</span><span class=w> </span><span class=nx>the</span><span class=w> </span><span class=nx>test</span><span class=p>;</span><span class=w> </span><span class=nx>these</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nx>flags</span><span class=w> </span><span class=nx>are</span><span class=w> </span><span class=nx>also</span><span class=w> </span><span class=nx>accessible</span><span class=w> </span><span class=nx>by</span><span class=w> </span><span class=err>&#39;</span><span class=k>go</span><span class=w> </span><span class=nx>test</span><span class=err>&#39;</span><span class=p>.</span><span class=w> </span><span class=nx>See</span><span class=w> </span><span class=err>&#39;</span><span class=k>go</span><span class=w> </span><span class=nx>help</span><span class=w> </span><span class=nx>testflag</span><span class=err>&#39;</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=nx>details</span><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nx>For</span><span class=w> </span><span class=nx>more</span><span class=w> </span><span class=nx>about</span><span class=w> </span><span class=nx>build</span><span class=w> </span><span class=nx>flags</span><span class=p>,</span><span class=w> </span><span class=nx>see</span><span class=w> </span><span class=err>&#39;</span><span class=k>go</span><span class=w> </span><span class=nx>help</span><span class=w> </span><span class=nx>build</span><span class=err>&#39;</span><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nx>For</span><span class=w> </span><span class=nx>more</span><span class=w> </span><span class=nx>about</span><span class=w> </span><span class=nx>specifying</span><span class=w> </span><span class=nx>packages</span><span class=p>,</span><span class=w> </span><span class=nx>see</span><span class=w> </span><span class=err>&#39;</span><span class=k>go</span><span class=w> </span><span class=nx>help</span><span class=w> </span><span class=nx>packages</span><span class=err>&#39;</span><span class=p>.</span><span class=w>
</span></span></span></code></pre></div><p>从给出的 <em>usage</em> 可以看到<code>go test</code>的参数分为三类，分别如下：</p><ul><li>Build flags：即编译参数，具体参数见<code>go help build</code>；</li><li>Test flags：<code>go test</code>所需的参数（如<code>-c</code>、<code>-json</code>），具体参数见<code>go help test</code>；</li><li>Binary flags：测试程序所需的参数，具体参数见<code>go help testflag</code>。</li></ul><p>接下来结合命令进行说明：</p><p>这条命令中的参数<code>-run=^TestLengthOfLongestSubstringV0$</code>和<code>-cover</code>属于binary flag。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Go data-lang=Go><span class=line><span class=cl><span class=err>$</span><span class=w> </span><span class=k>go</span><span class=w> </span><span class=nx>test</span><span class=w> </span><span class=o>-</span><span class=nx>run</span><span class=p>=^</span><span class=nx>TestLengthOfLongestSubstringV0</span><span class=err>$</span><span class=w> </span><span class=o>-</span><span class=nx>cover</span><span class=w>
</span></span></span></code></pre></div><p>这条命令中的<code>-c</code>参数愉test flag参数，作用是让<code>go test</code>直接生成可执行文件，但是不执行可执行文件。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Go data-lang=Go><span class=line><span class=cl><span class=err>$</span><span class=w> </span><span class=k>go</span><span class=w> </span><span class=nx>test</span><span class=w> </span><span class=o>-</span><span class=nx>c</span><span class=w>
</span></span></span></code></pre></div><p>这条命令中的<code>-gcflags="-m -N -l"</code>属于build flags。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Go data-lang=Go><span class=line><span class=cl><span class=err>$</span><span class=w> </span><span class=k>go</span><span class=w> </span><span class=nx>test</span><span class=w> </span><span class=o>-</span><span class=nx>gcflags</span><span class=p>=</span><span class=s>&#34;-m -N -l&#34;</span><span class=w>
</span></span></span></code></pre></div><h4 id=ide自动执行-vs-手动执行>IDE自动执行 vs 手动执行<a hidden class=anchor aria-hidden=true href=#ide自动执行-vs-手动执行>#</a></h4><p>和IDE自动执行相比，手动执行更灵活：</p><ul><li>可以一次执行多个（可以不是全部）测试函数；</li><li>可以指定输出信息（如输出格式<code>-json</code>，显示详情<code>-v</code>，输出代码覆盖率信息<code>-cover</code>，指定超时时间<code>-timeout</code>等）；</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://rand0m42195.github.io/tags/go/>Go</a></li><li><a href=https://rand0m42195.github.io/tags/testing/>Testing</a></li><li><a href=https://rand0m42195.github.io/tags/fuzzing/>Fuzzing</a></li></ul><nav class=paginav><a class=next href=https://rand0m42195.github.io/posts/writing-an-interpreter-in-rust/><span class=title>下一页 »</span><br><span>Writing An Interpreter In Rust (1): 开个头</span></a></nav></footer><div id=comments><script src=https://giscus.app/client.js data-repo=rand0m42195/rand0m42195.github.io data-repo-id=R_kgDOPzDcOw data-category=Announcements data-category-id=DIC_kwDOPzDcO84CvpUm data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=en crossorigin=anonymous async></script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://rand0m42195.github.io/>rand0m's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>