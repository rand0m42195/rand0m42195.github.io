<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>使用eBPF观测Go程序的goroutine状态变化 | rand0m's blog</title><meta name=keywords content="Go,eBPF,C"><meta name=description content="eBPF号称能动态地对内核进行编程，可以实现高效的网络处理、观测、追踪和安全功能。

Dynamically program the kernel for efficient networking, observability, tracing, and security

这篇博客就来体验一下用eBPF观测Go的goroutine调度，会涉及到uprobe原理、eBPF开发框架选择、eBPF程序的编写、用户态程序加载eBPF程序以及用户态程序和eBPF程序通过map交互等内容。
uprobe原理
uprobe（user-space probe）是 Linux 内核提供的一种机制，用来在 用户态程序的特定指令处 插入动态探针（probe）。uprobe 通过在用户态程序代码段指定位置写入一个 1 字节的断点指令（INT3, 0xCC），触发内核陷入（trap）进入 uprobe handler，再运行hook的代码。由于eBPF具有很好的安全性，所以可以用eBPF来编写hook代码，保证安全。
eBPF开发框架选择
最近几年eBPF发展的非常迅速，出现了优秀的开源eBPF开发框架，使得eBPF的开发难度大大降低。下面选取一些我知道的eBPF开发框架做介绍：

  
      
          项目
          特点
          语言
      
  
  
      
          bcc
          eBPF开发工具箱，适合教学&运维，依赖LLVM，较重。
          C、Python
      
      
          libbpf-bootstrap
          用C开发eBPF的模版/框架，官方推荐。
          C
      
      
          cilium/ebpf
          用Go开发eBPF的首选，eilium开源，能用于生产环境，无LLVM依赖
          C、Go
      
      
          bpftrace
          用类似awk的脚本语言开发eBPF，适合快速调试、验证。
          专用语法
      
      
          eunomia-bpf
          面向云原生的eBPF WASM化
          Rust
      
  

经过对比最终选择了使用cilium/ebpf来实现观测goroutine状态变化，原因有：bcc是一个很重的项目，有很多依赖环境。libbpf-bootstrap开发用户态程序相对麻烦一些。使用bpftrace开发需要了解他的脚本语言的语法（并不是通用的脚本语言），有一定的学习成本，而且开发复杂的eBPF程序也不太灵活。eunomia-bpf还没仔细研究过，以后会尝试。经过对比，我最终选择了对我来说最简单的cilium/ebpf，而且这个项目里有现成的examples，可以照猫画虎，很快就能实现一个简单uprobe功能。
用eBPF观测goroutine状态变化
eBPF程序
Go支持高并发的利器就是goroutine，而goroutine之所以能轻而易举的实现上万的并发，要归功于Go的调度策略，Go使用GMP调度模型。核心就是在用户态实现调度逻辑，避免系统级线程调度时用户态和内核态之间的切换开销。
Go的调度逻辑在源码的src/runtime/proc.go中，当scheduler切换goroutine状态时会调用runtime.casgstatus，runtime.casgstatus的原型如下，它的作用是：检查当前goroutine的状态是否old，如果是就把状态原子的更新为new，如果不是，不做更新。
func casgstatus(gp *g, oldval, newval uint32) 
要观测goroutine的状态切换，只需要把eBPF函数hook到这个函数的入口处，拿到这三个参数即可。
首先把cilium/ebpf拉到本地，进入examples目录，在创建一个uprobe_sched目录，创建一个uprobe_sched.c文件。
$ cd ebpf/examples
$ mkdir uprobe_sched
$ cd uprobe_sched
$ touch uprobe_sched.c
然后参考隔壁的examples/uretprobe/uretprobe.c，编写eBPF程序，主要逻辑就是，获取三个参数，第一个参数是指向g结构体的指针，第二个参数是old，第三个参数是new。其中goid在g结构体偏移0xA0（这个偏移和Go的版本相关，具体计算方法后面介绍），需要借助bpf_probe_read_user函数读取，读到goid之后将data_t结构体写入map中。"><meta name=author content="rand0m"><link rel=canonical href=https://rand0m42195.github.io/posts/ebpf-uprobe/><link crossorigin=anonymous href=/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://rand0m42195.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://rand0m42195.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://rand0m42195.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://rand0m42195.github.io/apple-touch-icon.png><link rel=mask-icon href=https://rand0m42195.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://rand0m42195.github.io/posts/ebpf-uprobe/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://rand0m42195.github.io/posts/ebpf-uprobe/"><meta property="og:site_name" content="rand0m's blog"><meta property="og:title" content="使用eBPF观测Go程序的goroutine状态变化"><meta property="og:description" content="eBPF号称能动态地对内核进行编程，可以实现高效的网络处理、观测、追踪和安全功能。
Dynamically program the kernel for efficient networking, observability, tracing, and security
这篇博客就来体验一下用eBPF观测Go的goroutine调度，会涉及到uprobe原理、eBPF开发框架选择、eBPF程序的编写、用户态程序加载eBPF程序以及用户态程序和eBPF程序通过map交互等内容。
uprobe原理 uprobe（user-space probe）是 Linux 内核提供的一种机制，用来在 用户态程序的特定指令处 插入动态探针（probe）。uprobe 通过在用户态程序代码段指定位置写入一个 1 字节的断点指令（INT3, 0xCC），触发内核陷入（trap）进入 uprobe handler，再运行hook的代码。由于eBPF具有很好的安全性，所以可以用eBPF来编写hook代码，保证安全。
eBPF开发框架选择 最近几年eBPF发展的非常迅速，出现了优秀的开源eBPF开发框架，使得eBPF的开发难度大大降低。下面选取一些我知道的eBPF开发框架做介绍：
项目 特点 语言 bcc eBPF开发工具箱，适合教学&运维，依赖LLVM，较重。 C、Python libbpf-bootstrap 用C开发eBPF的模版/框架，官方推荐。 C cilium/ebpf 用Go开发eBPF的首选，eilium开源，能用于生产环境，无LLVM依赖 C、Go bpftrace 用类似awk的脚本语言开发eBPF，适合快速调试、验证。 专用语法 eunomia-bpf 面向云原生的eBPF WASM化 Rust 经过对比最终选择了使用cilium/ebpf来实现观测goroutine状态变化，原因有：bcc是一个很重的项目，有很多依赖环境。libbpf-bootstrap开发用户态程序相对麻烦一些。使用bpftrace开发需要了解他的脚本语言的语法（并不是通用的脚本语言），有一定的学习成本，而且开发复杂的eBPF程序也不太灵活。eunomia-bpf还没仔细研究过，以后会尝试。经过对比，我最终选择了对我来说最简单的cilium/ebpf，而且这个项目里有现成的examples，可以照猫画虎，很快就能实现一个简单uprobe功能。
用eBPF观测goroutine状态变化 eBPF程序 Go支持高并发的利器就是goroutine，而goroutine之所以能轻而易举的实现上万的并发，要归功于Go的调度策略，Go使用GMP调度模型。核心就是在用户态实现调度逻辑，避免系统级线程调度时用户态和内核态之间的切换开销。
Go的调度逻辑在源码的src/runtime/proc.go中，当scheduler切换goroutine状态时会调用runtime.casgstatus，runtime.casgstatus的原型如下，它的作用是：检查当前goroutine的状态是否old，如果是就把状态原子的更新为new，如果不是，不做更新。
func casgstatus(gp *g, oldval, newval uint32) 要观测goroutine的状态切换，只需要把eBPF函数hook到这个函数的入口处，拿到这三个参数即可。
首先把cilium/ebpf拉到本地，进入examples目录，在创建一个uprobe_sched目录，创建一个uprobe_sched.c文件。
$ cd ebpf/examples $ mkdir uprobe_sched $ cd uprobe_sched $ touch uprobe_sched.c 然后参考隔壁的examples/uretprobe/uretprobe.c，编写eBPF程序，主要逻辑就是，获取三个参数，第一个参数是指向g结构体的指针，第二个参数是old，第三个参数是new。其中goid在g结构体偏移0xA0（这个偏移和Go的版本相关，具体计算方法后面介绍），需要借助bpf_probe_read_user函数读取，读到goid之后将data_t结构体写入map中。"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-11-27T19:16:56+08:00"><meta property="article:modified_time" content="2025-11-27T19:16:56+08:00"><meta property="article:tag" content="Go"><meta property="article:tag" content="EBPF"><meta property="article:tag" content="C"><meta name=twitter:card content="summary"><meta name=twitter:title content="使用eBPF观测Go程序的goroutine状态变化"><meta name=twitter:description content="eBPF号称能动态地对内核进行编程，可以实现高效的网络处理、观测、追踪和安全功能。

Dynamically program the kernel for efficient networking, observability, tracing, and security

这篇博客就来体验一下用eBPF观测Go的goroutine调度，会涉及到uprobe原理、eBPF开发框架选择、eBPF程序的编写、用户态程序加载eBPF程序以及用户态程序和eBPF程序通过map交互等内容。
uprobe原理
uprobe（user-space probe）是 Linux 内核提供的一种机制，用来在 用户态程序的特定指令处 插入动态探针（probe）。uprobe 通过在用户态程序代码段指定位置写入一个 1 字节的断点指令（INT3, 0xCC），触发内核陷入（trap）进入 uprobe handler，再运行hook的代码。由于eBPF具有很好的安全性，所以可以用eBPF来编写hook代码，保证安全。
eBPF开发框架选择
最近几年eBPF发展的非常迅速，出现了优秀的开源eBPF开发框架，使得eBPF的开发难度大大降低。下面选取一些我知道的eBPF开发框架做介绍：

  
      
          项目
          特点
          语言
      
  
  
      
          bcc
          eBPF开发工具箱，适合教学&运维，依赖LLVM，较重。
          C、Python
      
      
          libbpf-bootstrap
          用C开发eBPF的模版/框架，官方推荐。
          C
      
      
          cilium/ebpf
          用Go开发eBPF的首选，eilium开源，能用于生产环境，无LLVM依赖
          C、Go
      
      
          bpftrace
          用类似awk的脚本语言开发eBPF，适合快速调试、验证。
          专用语法
      
      
          eunomia-bpf
          面向云原生的eBPF WASM化
          Rust
      
  

经过对比最终选择了使用cilium/ebpf来实现观测goroutine状态变化，原因有：bcc是一个很重的项目，有很多依赖环境。libbpf-bootstrap开发用户态程序相对麻烦一些。使用bpftrace开发需要了解他的脚本语言的语法（并不是通用的脚本语言），有一定的学习成本，而且开发复杂的eBPF程序也不太灵活。eunomia-bpf还没仔细研究过，以后会尝试。经过对比，我最终选择了对我来说最简单的cilium/ebpf，而且这个项目里有现成的examples，可以照猫画虎，很快就能实现一个简单uprobe功能。
用eBPF观测goroutine状态变化
eBPF程序
Go支持高并发的利器就是goroutine，而goroutine之所以能轻而易举的实现上万的并发，要归功于Go的调度策略，Go使用GMP调度模型。核心就是在用户态实现调度逻辑，避免系统级线程调度时用户态和内核态之间的切换开销。
Go的调度逻辑在源码的src/runtime/proc.go中，当scheduler切换goroutine状态时会调用runtime.casgstatus，runtime.casgstatus的原型如下，它的作用是：检查当前goroutine的状态是否old，如果是就把状态原子的更新为new，如果不是，不做更新。
func casgstatus(gp *g, oldval, newval uint32) 
要观测goroutine的状态切换，只需要把eBPF函数hook到这个函数的入口处，拿到这三个参数即可。
首先把cilium/ebpf拉到本地，进入examples目录，在创建一个uprobe_sched目录，创建一个uprobe_sched.c文件。
$ cd ebpf/examples
$ mkdir uprobe_sched
$ cd uprobe_sched
$ touch uprobe_sched.c
然后参考隔壁的examples/uretprobe/uretprobe.c，编写eBPF程序，主要逻辑就是，获取三个参数，第一个参数是指向g结构体的指针，第二个参数是old，第三个参数是new。其中goid在g结构体偏移0xA0（这个偏移和Go的版本相关，具体计算方法后面介绍），需要借助bpf_probe_read_user函数读取，读到goid之后将data_t结构体写入map中。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://rand0m42195.github.io/posts/"},{"@type":"ListItem","position":2,"name":"使用eBPF观测Go程序的goroutine状态变化","item":"https://rand0m42195.github.io/posts/ebpf-uprobe/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"使用eBPF观测Go程序的goroutine状态变化","name":"使用eBPF观测Go程序的goroutine状态变化","description":"eBPF号称能动态地对内核进行编程，可以实现高效的网络处理、观测、追踪和安全功能。\nDynamically program the kernel for efficient networking, observability, tracing, and security\n这篇博客就来体验一下用eBPF观测Go的goroutine调度，会涉及到uprobe原理、eBPF开发框架选择、eBPF程序的编写、用户态程序加载eBPF程序以及用户态程序和eBPF程序通过map交互等内容。\nuprobe原理 uprobe（user-space probe）是 Linux 内核提供的一种机制，用来在 用户态程序的特定指令处 插入动态探针（probe）。uprobe 通过在用户态程序代码段指定位置写入一个 1 字节的断点指令（INT3, 0xCC），触发内核陷入（trap）进入 uprobe handler，再运行hook的代码。由于eBPF具有很好的安全性，所以可以用eBPF来编写hook代码，保证安全。\neBPF开发框架选择 最近几年eBPF发展的非常迅速，出现了优秀的开源eBPF开发框架，使得eBPF的开发难度大大降低。下面选取一些我知道的eBPF开发框架做介绍：\n项目 特点 语言 bcc eBPF开发工具箱，适合教学\u0026amp;运维，依赖LLVM，较重。 C、Python libbpf-bootstrap 用C开发eBPF的模版/框架，官方推荐。 C cilium/ebpf 用Go开发eBPF的首选，eilium开源，能用于生产环境，无LLVM依赖 C、Go bpftrace 用类似awk的脚本语言开发eBPF，适合快速调试、验证。 专用语法 eunomia-bpf 面向云原生的eBPF WASM化 Rust 经过对比最终选择了使用cilium/ebpf来实现观测goroutine状态变化，原因有：bcc是一个很重的项目，有很多依赖环境。libbpf-bootstrap开发用户态程序相对麻烦一些。使用bpftrace开发需要了解他的脚本语言的语法（并不是通用的脚本语言），有一定的学习成本，而且开发复杂的eBPF程序也不太灵活。eunomia-bpf还没仔细研究过，以后会尝试。经过对比，我最终选择了对我来说最简单的cilium/ebpf，而且这个项目里有现成的examples，可以照猫画虎，很快就能实现一个简单uprobe功能。\n用eBPF观测goroutine状态变化 eBPF程序 Go支持高并发的利器就是goroutine，而goroutine之所以能轻而易举的实现上万的并发，要归功于Go的调度策略，Go使用GMP调度模型。核心就是在用户态实现调度逻辑，避免系统级线程调度时用户态和内核态之间的切换开销。\nGo的调度逻辑在源码的src/runtime/proc.go中，当scheduler切换goroutine状态时会调用runtime.casgstatus，runtime.casgstatus的原型如下，它的作用是：检查当前goroutine的状态是否old，如果是就把状态原子的更新为new，如果不是，不做更新。\nfunc casgstatus(gp *g, oldval, newval uint32) 要观测goroutine的状态切换，只需要把eBPF函数hook到这个函数的入口处，拿到这三个参数即可。\n首先把cilium/ebpf拉到本地，进入examples目录，在创建一个uprobe_sched目录，创建一个uprobe_sched.c文件。\n$ cd ebpf/examples $ mkdir uprobe_sched $ cd uprobe_sched $ touch uprobe_sched.c 然后参考隔壁的examples/uretprobe/uretprobe.c，编写eBPF程序，主要逻辑就是，获取三个参数，第一个参数是指向g结构体的指针，第二个参数是old，第三个参数是new。其中goid在g结构体偏移0xA0（这个偏移和Go的版本相关，具体计算方法后面介绍），需要借助bpf_probe_read_user函数读取，读到goid之后将data_t结构体写入map中。\n","keywords":["Go","eBPF","C"],"articleBody":"eBPF号称能动态地对内核进行编程，可以实现高效的网络处理、观测、追踪和安全功能。\nDynamically program the kernel for efficient networking, observability, tracing, and security\n这篇博客就来体验一下用eBPF观测Go的goroutine调度，会涉及到uprobe原理、eBPF开发框架选择、eBPF程序的编写、用户态程序加载eBPF程序以及用户态程序和eBPF程序通过map交互等内容。\nuprobe原理 uprobe（user-space probe）是 Linux 内核提供的一种机制，用来在 用户态程序的特定指令处 插入动态探针（probe）。uprobe 通过在用户态程序代码段指定位置写入一个 1 字节的断点指令（INT3, 0xCC），触发内核陷入（trap）进入 uprobe handler，再运行hook的代码。由于eBPF具有很好的安全性，所以可以用eBPF来编写hook代码，保证安全。\neBPF开发框架选择 最近几年eBPF发展的非常迅速，出现了优秀的开源eBPF开发框架，使得eBPF的开发难度大大降低。下面选取一些我知道的eBPF开发框架做介绍：\n项目 特点 语言 bcc eBPF开发工具箱，适合教学\u0026运维，依赖LLVM，较重。 C、Python libbpf-bootstrap 用C开发eBPF的模版/框架，官方推荐。 C cilium/ebpf 用Go开发eBPF的首选，eilium开源，能用于生产环境，无LLVM依赖 C、Go bpftrace 用类似awk的脚本语言开发eBPF，适合快速调试、验证。 专用语法 eunomia-bpf 面向云原生的eBPF WASM化 Rust 经过对比最终选择了使用cilium/ebpf来实现观测goroutine状态变化，原因有：bcc是一个很重的项目，有很多依赖环境。libbpf-bootstrap开发用户态程序相对麻烦一些。使用bpftrace开发需要了解他的脚本语言的语法（并不是通用的脚本语言），有一定的学习成本，而且开发复杂的eBPF程序也不太灵活。eunomia-bpf还没仔细研究过，以后会尝试。经过对比，我最终选择了对我来说最简单的cilium/ebpf，而且这个项目里有现成的examples，可以照猫画虎，很快就能实现一个简单uprobe功能。\n用eBPF观测goroutine状态变化 eBPF程序 Go支持高并发的利器就是goroutine，而goroutine之所以能轻而易举的实现上万的并发，要归功于Go的调度策略，Go使用GMP调度模型。核心就是在用户态实现调度逻辑，避免系统级线程调度时用户态和内核态之间的切换开销。\nGo的调度逻辑在源码的src/runtime/proc.go中，当scheduler切换goroutine状态时会调用runtime.casgstatus，runtime.casgstatus的原型如下，它的作用是：检查当前goroutine的状态是否old，如果是就把状态原子的更新为new，如果不是，不做更新。\nfunc casgstatus(gp *g, oldval, newval uint32) 要观测goroutine的状态切换，只需要把eBPF函数hook到这个函数的入口处，拿到这三个参数即可。\n首先把cilium/ebpf拉到本地，进入examples目录，在创建一个uprobe_sched目录，创建一个uprobe_sched.c文件。\n$ cd ebpf/examples $ mkdir uprobe_sched $ cd uprobe_sched $ touch uprobe_sched.c 然后参考隔壁的examples/uretprobe/uretprobe.c，编写eBPF程序，主要逻辑就是，获取三个参数，第一个参数是指向g结构体的指针，第二个参数是old，第三个参数是new。其中goid在g结构体偏移0xA0（这个偏移和Go的版本相关，具体计算方法后面介绍），需要借助bpf_probe_read_user函数读取，读到goid之后将data_t结构体写入map中。\n//go:build ignore #include \"common.h\" #include \"bpf_tracing.h\" #define GOID_OFFSET 0xA0\t// 0xA0是goid在g结构体中的偏移 struct data_t { u64 goid; u32 old_status; u32 new_status; }; // 定义一个PERF_EVENT map,将执行的结果保存到map中，供用户态程序消费 struct { __uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY); __type(value, struct data_t); } events SEC(\".maps\"); SEC(\"uprobe/runtime.casgstatus\") int monitor_sched(struct pt_regs *ctx) { u64 goid = 0; u64 gp = (u64)PT_REGS_PARM1(ctx);\t// 获取第一个参数 u32 old = (u64)PT_REGS_PARM2(ctx);\t// 获取第二个参数 u32 new = (u64)PT_REGS_PARM3(ctx);\t// 获取第三个参数 if (gp == 0) return 0; if (bpf_probe_read_user(\u0026goid, sizeof(goid), (void *)(gp + GOID_OFFSET))) {\t// 通过bpf helper函数读取指定地址的内容 return 0; } struct data_t data = { .goid = goid, .old_status = old, .new_status = new, }; // bpf_printk(\"casgstatus: g=0x%d old=%d new=%d\\n\", goid, old, new); bpf_perf_event_output(ctx, \u0026events, BPF_F_CURRENT_CPU, \u0026data, sizeof(data)); return 0; } char LICENSE[] SEC(\"license\") = \"GPL\"; 这就是eBPF程序，很简单，长度50行以内。\n用户态程序 用户态程序的职责就是把eBPF程序加载到内核，attach到指定点，然后读取map内容并打印。\n在uprobe_sched目录下创建main.go文件\n$ touch main.go 参考examples/uretprobe/main.go，可以写出我们自己的main.go，其中多了一个将表示状态的整数转换为可读性更好的字符串函数。\n//go:build amd64 \u0026\u0026 linux package main import ( \"bytes\" \"encoding/binary\" \"errors\" \"fmt\" \"log\" \"os\" \"os/signal\" \"syscall\" \"github.com/cilium/ebpf/link\" \"github.com/cilium/ebpf/perf\" \"github.com/cilium/ebpf/rlimit\" ) //go:generate go tool bpf2go -tags linux -target amd64 bpf uprobe_sched.c -- -I../headers // G status from src/runtime/runtime2.go const ( Gidle = iota Grunnable Grunning Gsyscall Gwaiting GmoribundUnused Gdead GenqueueUnused Gcopystack Gpreempted ) func GStatus(n uint32) string { switch n { case Gidle: return \"idle\" case Grunnable: return \"runnable\" case Grunning: return \"running\" case Gsyscall: return \"syscall\" case Gwaiting: return \"waiting\" case GmoribundUnused: return \"moribund\" case Gdead: return \"dead\" case GenqueueUnused: return \"enqueue\" case Gcopystack: return \"copystack\" case Gpreempted: return \"preempted\" default: return \"unkonwn\" } } func main() { if len(os.Args) != 3 { fmt.Printf(\"Usage: %s BINARY SYMBOL\\n\", os.Args[0]) return } binPath := os.Args[1] symbol := os.Args[2] stopper := make(chan os.Signal, 1) signal.Notify(stopper, os.Interrupt, syscall.SIGTERM) // Allow the current process to lock memory for eBPF resources. if err := rlimit.RemoveMemlock(); err != nil { log.Fatal(err) } // Load pre-compiled programs and maps into the kernel. objs := bpfObjects{} if err := loadBpfObjects(\u0026objs, nil); err != nil { log.Fatalf(\"loading objects: %s\", err) } defer objs.Close() // Open an ELF binary and read its symbols. ex, err := link.OpenExecutable(binPath) if err != nil { log.Fatalf(\"opening executable: %s\", err) } up, err := ex.Uprobe(symbol, objs.MonitorSched, nil) if err != nil { log.Fatalf(\"creating uretprobe: %s\", err) } defer up.Close() // Open a perf event reader from userspace on the PERF_EVENT_ARRAY map // described in the eBPF C program. rd, err := perf.NewReader(objs.Events, os.Getpagesize()) if err != nil { log.Fatalf(\"creating perf event reader: %s\", err) } defer rd.Close() go func() { // Wait for a signal and close the perf reader, // which will interrupt rd.Read() and make the program exit. \u003c-stopper log.Println(\"Received signal, exiting program..\") if err := rd.Close(); err != nil { log.Fatalf(\"closing perf event reader: %s\", err) } }() log.Printf(\"Listening for events..\") // bpfEvent is generated by bpf2go. var event bpfDataT fmt.Printf(\"%-15s %-20s %-20s\\n\", \"Goroutine ID\", \"Old Status\", \"New Status\") for { record, err := rd.Read() if err != nil { if errors.Is(err, perf.ErrClosed) { return } log.Printf(\"reading from perf event reader: %s\", err) continue } if record.LostSamples != 0 { log.Printf(\"perf event ring buffer full, dropped %d samples\", record.LostSamples) continue } // Parse the perf event entry into a bpfEvent structure. if err := binary.Read(bytes.NewBuffer(record.RawSample), binary.LittleEndian, \u0026event); err != nil { log.Printf(\"parsing perf event: %s\", err) continue } fmt.Printf(\"%-10d %-20s %-20s\\n\", event.Goid, GStatus(event.OldStatus), GStatus(event.NewStatus)) } } 然后生成ebpf程序和加载程序：\n$ go generate // 生成ebpf程序和操作ebpf程序的函数 $ go build\t// 编译生成加载eBPF的可执行程序 $ ls bpf_x86_bpfel.go bpf_x86_bpfel.o main.go uprobe_sched* uprobe_sched.c $ ./uprobe_sched Usage: ./uprobe_sched BINARY SYMBOL 接下来就找一个Go程序测试一下，随便写一个Go程序到/tmp/test.go中。\n// 被观测程序的源码 package main import ( \"math/rand\" \"time\" ) func task() { n := rand.Int() % 5 for i := 0; i \u003c n; i++ { t := rand.Int() % 10 time.Sleep(time.Duration(t * 100 * int(time.Millisecond))) } } func main() { for { go task() time.Sleep(time.Second) } } 创建并编译上述代码。\n$ cd /tmp $ touch test.go $ go build test.go 接下来就是见证奇迹的时刻了，运行uprobe_sched程序，指定被观测二进制的路径以及要观测的函数，观察输出结果如下：\n$ sudo ./uprobe_sched /tmp/test runtime.casgstatus 2025/11/27 21:01:36 Listening for events.. Goroutine ID Old Status New Status 0 unkonwn unkonwn 0 unkonwn idle 14757395258964568840 unkonwn unkonwn 0 unkonwn idle 14757395258964568840 unkonwn unkonwn 0 unkonwn idle 14757395258964568840 unkonwn unkonwn 貌似这个输出不对，goroutine ID以及状态都不符合预期，这是为什么呢？经过一番折腾，最终找到了原因——eBPF程序获取的参数有问题，runtime.casgstatus函数的三个参数分别在rax，rbx和rcx寄存器中，但是PT_REGS_PARMn(ctx)宏获取到的寄存器分别是rdi，rsi和rdx寄存器。前三个参数分别用rdi，rsi和rdx寄存器传递确实是x86_64的Linux的规范，但问题是Go的runtime不遵守这个规范，所以使用PT_REGS_PARMn(ctx)宏并没有正确获取参数。那怎么知道到底是怎么传递这三个参数的呢？可以对被测试程序的指定函数进行反汇编来确认参数是怎么传递的。以被测试的test程序为例，反汇编命令如下：\n$ go tool objdump -S -gnu -s runtime.casgstatus test TEXT runtime.casgstatus(SB) /usr/local/go/src/runtime/proc.go func casgstatus(gp *g, oldval, newval uint32) { 0x4363e0\t55\tPUSHQ BP // push %rbp 0x4363e1\t4889e5\tMOVQ SP, BP // mov %rsp,%rbp 0x4363e4\t4883ec40\tSUBQ $0x40, SP // sub $0x40,%rsp if (oldval\u0026_Gscan != 0) || (newval\u0026_Gscan != 0) || oldval == newval { 0x4363e8\t4889442450\tMOVQ AX, 0x50(SP) // mov %rax,0x50(%rsp) 0x4363ed\t895c2458\tMOVL BX, 0x58(SP) // mov %ebx,0x58(%rsp) 0x4363f1\t894c245c\tMOVL CX, 0x5c(SP) // mov %ecx,0x5c(%rsp) ...... 如果对汇编比较熟悉，可以确定三个参数分别是通过rax、rbx和rcx传递的，如果不熟悉也没关系，直接把反汇编结果扔给GPT，让GPT给你答案即可。确定了问题原因，下面把eBPF程序中获取参数的三行代码改成如下。\n// u64 gp = (u64)PT_REGS_PARM1(ctx); // u32 old = (u64)PT_REGS_PARM2(ctx); // u32 new = (u64)PT_REGS_PARM3(ctx); u64 gp = (u64)ctx-\u003erax; u32 old = (u32)ctx-\u003erbx; u32 new = (u32)ctx-\u003ercx; 再重新生成eBPF程序和加载程序，然后观察，这次没有出现意外，显示正常了。\n$ go generate $ go build $ sudo ./uprobe_sched /tmp/test runtime.casgstatus 2025/11/27 21:18:26 Listening for events.. Goroutine ID Old Status New Status 0 idle dead 0 dead runnable 1 runnable running 0 idle dead 0 dead runnable 0 idle dead 2 runnable running 2 running waiting PS：在确认了Go的传参规范和Linux的传参规范不一样之后，去搜了一下相关文档，还真的有文档介绍较新版本的Go在amd64架构下的传参约定。对于整形的参数和结果，Go使用一下寄存器进行传递。这个通过反汇编观察到的结论一致。\nRAX, RBX, RCX, RDI, RSI, R8, R9, R10, R11 总结 使用cilium/ebpf开发uprobe分为几个部分：\n分析被观测的对象，确定要观测的位置； 编写eBPF程序，对于观测程序，一般是获取一些环境信息（如参数、返回值等），而不改变被观测对象的环境。获取到的环境信息一般要写入map供用户态程序消费；获取环境信息就需要根据实际情况进行分析，没有绝对统一的方法。 编写用户态程序，用户态程序负责open、load和attach eBPF程序，并且从map中读出eBPF程序写入的内容并进行处理。 借助eBPF的开发框架，开发uprobe难度并不大。但是需要注意的是如何获取环境信息，像这里举的例子，获取参数就不能简单的用宏来获取。另外这个例子里要确定goid在g结构体中的偏移，我使用的方法是用dlv动态调试。\n$ dlv exec test // 调试被测程序 Type 'help' for list of commands. (dlv) b runtime.casgstatus\t// 在观测点设置断点 Breakpoint 1 set at 0x4363e4 for runtime.casgstatus() /usr/local/go/src/runtime/proc.go:1175 (dlv) c\t// 运行程序 \u003e [Breakpoint 1] runtime.casgstatus() /usr/local/go/src/runtime/proc.go:1175 (hits total:1) (PC: 0x4363e4) Warning: debugging optimized function 1170:\t// and casfrom_Gscanstatus instead. 1171:\t// casgstatus will loop if the g-\u003eatomicstatus is in a Gscan status until the routine that 1172:\t// put it in the Gscan state is finished. 1173:\t// 1174:\t//go:nosplit =\u003e1175:\tfunc casgstatus(gp *g, oldval, newval uint32) { 1176:\tif (oldval\u0026_Gscan != 0) || (newval\u0026_Gscan != 0) || oldval == newval { 1177:\tsystemstack(func() { 1178:\t// Call on the systemstack to prevent print and throw from counting 1179:\t// against the nosplit stack reservation. 1180:\tprint(\"runtime: casgstatus: oldval=\", hex(oldval), \" newval=\", hex(newval), \"\\n\") (dlv) args\t// 查看参数信息 gp = (*runtime.g)(0xc0000061c0)\t// 这里是g结构体的起始地址 oldval = 0 newval = 6 (dlv) p \u0026gp.goid (*uint64)(0xc000006260)\t// 这里是g结构体中goid成员的地址，所以goid在g中的偏移量是 0xc000006260 - 0xc0000061c0 = 0xa0 ","wordCount":"1057","inLanguage":"zh","datePublished":"2025-11-27T19:16:56+08:00","dateModified":"2025-11-27T19:16:56+08:00","author":{"@type":"Person","name":"rand0m"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://rand0m42195.github.io/posts/ebpf-uprobe/"},"publisher":{"@type":"Organization","name":"rand0m's blog","logo":{"@type":"ImageObject","url":"https://rand0m42195.github.io/favicon.ico"}}}</script><link rel=icon href=/favicon.ico type=image/x-icon><link rel=icon href=/favicon-16x16.png type=image/png size=16x16><link rel=icon href=/favicon-32x32.png type=image/png size=32x32><link rel=icon href=/favicon-192x192.png type=image/png size=192x192><link rel=icon href=/favicon-512x512.png type=image/png size=512x512></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://rand0m42195.github.io/ accesskey=h title="rand0m's blog (Alt + H)">rand0m's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://rand0m42195.github.io/posts/ title=文章><span>文章</span></a></li><li><a href=https://rand0m42195.github.io/about/ title=关于><span>关于</span></a></li><li><a href=https://github.com/rand0m42195 title=GitHub><span>GitHub</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://rand0m42195.github.io/>主页</a>&nbsp;»&nbsp;<a href=https://rand0m42195.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">使用eBPF观测Go程序的goroutine状态变化</h1><div class=post-meta><span title='2025-11-27 19:16:56 +0800 +0800'>十一月 27, 2025</span>&nbsp;·&nbsp;5 分钟&nbsp;·&nbsp;rand0m</div></header><div class=post-content><p><a href=https://ebpf.io/>eBPF</a>号称能动态地对内核进行编程，可以实现高效的网络处理、观测、追踪和安全功能。</p><blockquote><p>Dynamically program the kernel for efficient networking, observability, tracing, and security</p></blockquote><p>这篇博客就来体验一下用eBPF观测Go的goroutine调度，会涉及到uprobe原理、eBPF开发框架选择、eBPF程序的编写、用户态程序加载eBPF程序以及用户态程序和eBPF程序通过map交互等内容。</p><h2 id=uprobe原理>uprobe原理<a hidden class=anchor aria-hidden=true href=#uprobe原理>#</a></h2><p><code>uprobe</code>（user-space probe）是 Linux 内核提供的一种机制，用来在 用户态程序的特定指令处 插入动态探针（probe）。<code>uprobe</code> 通过在用户态程序代码段指定位置写入一个 1 字节的断点指令（INT3, 0xCC），触发内核陷入（trap）进入 uprobe handler，再运行hook的代码。由于eBPF具有很好的安全性，所以可以用eBPF来编写hook代码，保证安全。</p><h2 id=ebpf开发框架选择>eBPF开发框架选择<a hidden class=anchor aria-hidden=true href=#ebpf开发框架选择>#</a></h2><p>最近几年eBPF发展的非常迅速，出现了优秀的开源eBPF开发框架，使得eBPF的开发难度大大降低。下面选取一些我知道的eBPF开发框架做介绍：</p><table><thead><tr><th>项目</th><th>特点</th><th>语言</th></tr></thead><tbody><tr><td><a href=https://github.com/iovisor/bcc>bcc</a></td><td>eBPF开发工具箱，适合教学&运维，依赖LLVM，较重。</td><td>C、Python</td></tr><tr><td><a href="https://github.com/libbpf/libbpf-bootstrap/tree/master?tab=readme-ov-file">libbpf-bootstrap</a></td><td>用C开发eBPF的模版/框架，官方推荐。</td><td>C</td></tr><tr><td><a href="https://github.com/libbpf/libbpf-bootstrap/tree/master?tab=readme-ov-file">cilium/ebpf</a></td><td>用Go开发eBPF的首选，eilium开源，能用于生产环境，无LLVM依赖</td><td>C、Go</td></tr><tr><td><a href=https://github.com/bpftrace/bpftrace>bpftrace</a></td><td>用类似awk的脚本语言开发eBPF，适合快速调试、验证。</td><td>专用语法</td></tr><tr><td><a href=https://github.com/eunomia-bpf/eunomia-bpf>eunomia-bpf</a></td><td>面向云原生的eBPF WASM化</td><td>Rust</td></tr></tbody></table><p>经过对比最终选择了使用cilium/ebpf来实现观测goroutine状态变化，原因有：bcc是一个很重的项目，有很多依赖环境。libbpf-bootstrap开发用户态程序相对麻烦一些。使用bpftrace开发需要了解他的脚本语言的语法（并不是通用的脚本语言），有一定的学习成本，而且开发复杂的eBPF程序也不太灵活。eunomia-bpf还没仔细研究过，以后会尝试。经过对比，我最终选择了对我来说最简单的cilium/ebpf，而且这个项目里有现成的<a href=https://github.com/cilium/ebpf/tree/main/examples>examples</a>，可以照猫画虎，很快就能实现一个简单uprobe功能。</p><h2 id=用ebpf观测goroutine状态变化>用eBPF观测goroutine状态变化<a hidden class=anchor aria-hidden=true href=#用ebpf观测goroutine状态变化>#</a></h2><h3 id=ebpf程序>eBPF程序<a hidden class=anchor aria-hidden=true href=#ebpf程序>#</a></h3><p>Go支持高并发的利器就是goroutine，而goroutine之所以能轻而易举的实现上万的并发，要归功于Go的调度策略，Go使用GMP调度模型。核心就是在用户态实现调度逻辑，避免系统级线程调度时用户态和内核态之间的切换开销。</p><p>Go的调度逻辑在源码的src/runtime/proc.go中，当scheduler切换goroutine状态时会调用<code>runtime.casgstatus</code>，runtime.casgstatus的原型如下，它的作用是：检查当前goroutine的状态是否old，如果是就把状态原子的更新为new，如果不是，不做更新。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Go data-lang=Go><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>casgstatus</span><span class=p>(</span><span class=nx>gp</span><span class=w> </span><span class=o>*</span><span class=nx>g</span><span class=p>,</span><span class=w> </span><span class=nx>oldval</span><span class=p>,</span><span class=w> </span><span class=nx>newval</span><span class=w> </span><span class=kt>uint32</span><span class=p>)</span><span class=w> 
</span></span></span></code></pre></div><p>要观测goroutine的状态切换，只需要把eBPF函数hook到这个函数的入口处，拿到这三个参数即可。</p><p>首先把<a href=https://github.com/cilium/ebpf>cilium/ebpf</a>拉到本地，进入examples目录，在创建一个uprobe_sched目录，创建一个uprobe_sched.c文件。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ <span class=nb>cd</span> ebpf/examples
</span></span><span class=line><span class=cl>$ mkdir uprobe_sched
</span></span><span class=line><span class=cl>$ <span class=nb>cd</span> uprobe_sched
</span></span><span class=line><span class=cl>$ touch uprobe_sched.c
</span></span></code></pre></div><p>然后参考隔壁的<a href=https://github.com/cilium/ebpf/blob/main/examples/uretprobe/uretprobe.c>examples/uretprobe/uretprobe.c</a>，编写eBPF程序，主要逻辑就是，获取三个参数，第一个参数是指向g结构体的指针，第二个参数是old，第三个参数是new。其中goid在g结构体偏移0xA0（这个偏移和Go的版本相关，具体计算方法后面介绍），需要借助<code>bpf_probe_read_user</code>函数读取，读到goid之后将data_t结构体写入map中。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>//go:build ignore
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#include &#34;common.h&#34;</span>
</span></span><span class=line><span class=cl><span class=c1>#include &#34;bpf_tracing.h&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#define GOID_OFFSET 0xA0	// 0xA0是goid在g结构体中的偏移</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>struct data_t <span class=o>{</span>
</span></span><span class=line><span class=cl>	u64 goid<span class=p>;</span>
</span></span><span class=line><span class=cl>	u32 old_status<span class=p>;</span>
</span></span><span class=line><span class=cl>	u32 new_status<span class=p>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>// 定义一个PERF_EVENT map,将执行的结果保存到map中，供用户态程序消费
</span></span><span class=line><span class=cl>struct <span class=o>{</span>
</span></span><span class=line><span class=cl>	__uint<span class=o>(</span>type, BPF_MAP_TYPE_PERF_EVENT_ARRAY<span class=o>)</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	__type<span class=o>(</span>value, struct data_t<span class=o>)</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span> events SEC<span class=o>(</span><span class=s2>&#34;.maps&#34;</span><span class=o>)</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>SEC<span class=o>(</span><span class=s2>&#34;uprobe/runtime.casgstatus&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>int monitor_sched<span class=o>(</span>struct pt_regs *ctx<span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>	u64 <span class=nv>goid</span> <span class=o>=</span> 0<span class=p>;</span>
</span></span><span class=line><span class=cl>	u64 <span class=nv>gp</span>   <span class=o>=</span> <span class=o>(</span>u64<span class=o>)</span>PT_REGS_PARM1<span class=o>(</span>ctx<span class=o>)</span><span class=p>;</span>		// 获取第一个参数
</span></span><span class=line><span class=cl>	u32 <span class=nv>old</span>   <span class=o>=</span> <span class=o>(</span>u64<span class=o>)</span>PT_REGS_PARM2<span class=o>(</span>ctx<span class=o>)</span><span class=p>;</span>	// 获取第二个参数
</span></span><span class=line><span class=cl>	u32 <span class=nv>new</span>   <span class=o>=</span> <span class=o>(</span>u64<span class=o>)</span>PT_REGS_PARM3<span class=o>(</span>ctx<span class=o>)</span><span class=p>;</span>	// 获取第三个参数
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=o>(</span><span class=nv>gp</span> <span class=o>==</span> 0<span class=o>)</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> 0<span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=o>(</span>bpf_probe_read_user<span class=o>(</span><span class=p>&amp;</span>goid, sizeof<span class=o>(</span>goid<span class=o>)</span>, <span class=o>(</span>void *<span class=o>)(</span>gp + GOID_OFFSET<span class=o>)))</span> <span class=o>{</span>	// 通过bpf helper函数读取指定地址的内容
</span></span><span class=line><span class=cl>		<span class=k>return</span> 0<span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	struct data_t <span class=nv>data</span> <span class=o>=</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>		.goid       <span class=o>=</span> goid,
</span></span><span class=line><span class=cl>		.old_status <span class=o>=</span> old,
</span></span><span class=line><span class=cl>		.new_status <span class=o>=</span> new,
</span></span><span class=line><span class=cl>	<span class=o>}</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	// bpf_printk<span class=o>(</span><span class=s2>&#34;casgstatus: g=0x%d old=%d new=%d\n&#34;</span>, goid, old, new<span class=o>)</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	bpf_perf_event_output<span class=o>(</span>ctx, <span class=p>&amp;</span>events, BPF_F_CURRENT_CPU, <span class=p>&amp;</span>data, sizeof<span class=o>(</span>data<span class=o>))</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> 0<span class=p>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>char LICENSE<span class=o>[]</span> SEC<span class=o>(</span><span class=s2>&#34;license&#34;</span><span class=o>)</span> <span class=o>=</span> <span class=s2>&#34;GPL&#34;</span><span class=p>;</span>
</span></span></code></pre></div><p>这就是eBPF程序，很简单，长度50行以内。</p><h3 id=用户态程序>用户态程序<a hidden class=anchor aria-hidden=true href=#用户态程序>#</a></h3><p>用户态程序的职责就是把eBPF程序加载到内核，attach到指定点，然后读取map内容并打印。</p><p>在uprobe_sched目录下创建main.go文件</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ touch main.go
</span></span></code></pre></div><p>参考<a href=https://github.com/cilium/ebpf/blob/main/examples/uretprobe/main.go>examples/uretprobe/main.go</a>，可以写出我们自己的main.go，其中多了一个将表示状态的整数转换为可读性更好的字符串函数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=cp>//go:build amd64 &amp;&amp; linux</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kn>package</span><span class=w> </span><span class=nx>main</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kn>import</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=s>&#34;bytes&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=s>&#34;encoding/binary&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=s>&#34;errors&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=s>&#34;fmt&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=s>&#34;log&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=s>&#34;os&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=s>&#34;os/signal&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=s>&#34;syscall&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=s>&#34;github.com/cilium/ebpf/link&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=s>&#34;github.com/cilium/ebpf/perf&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=s>&#34;github.com/cilium/ebpf/rlimit&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>//go:generate go tool bpf2go -tags linux -target amd64 bpf uprobe_sched.c -- -I../headers</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// G status from src/runtime/runtime2.go</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>const</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>Gidle</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=kc>iota</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>Grunnable</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>Grunning</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>Gsyscall</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>Gwaiting</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>GmoribundUnused</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>Gdead</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>GenqueueUnused</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>Gcopystack</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>Gpreempted</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>func</span><span class=w> </span><span class=nf>GStatus</span><span class=p>(</span><span class=nx>n</span><span class=w> </span><span class=kt>uint32</span><span class=p>)</span><span class=w> </span><span class=kt>string</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>switch</span><span class=w> </span><span class=nx>n</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>case</span><span class=w> </span><span class=nx>Gidle</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>return</span><span class=w> </span><span class=s>&#34;idle&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>case</span><span class=w> </span><span class=nx>Grunnable</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>return</span><span class=w> </span><span class=s>&#34;runnable&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>case</span><span class=w> </span><span class=nx>Grunning</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>return</span><span class=w> </span><span class=s>&#34;running&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>case</span><span class=w> </span><span class=nx>Gsyscall</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>return</span><span class=w> </span><span class=s>&#34;syscall&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>case</span><span class=w> </span><span class=nx>Gwaiting</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>return</span><span class=w> </span><span class=s>&#34;waiting&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>case</span><span class=w> </span><span class=nx>GmoribundUnused</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>return</span><span class=w> </span><span class=s>&#34;moribund&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>case</span><span class=w> </span><span class=nx>Gdead</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>return</span><span class=w> </span><span class=s>&#34;dead&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>case</span><span class=w> </span><span class=nx>GenqueueUnused</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>return</span><span class=w> </span><span class=s>&#34;enqueue&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>case</span><span class=w> </span><span class=nx>Gcopystack</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>return</span><span class=w> </span><span class=s>&#34;copystack&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>case</span><span class=w> </span><span class=nx>Gpreempted</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>return</span><span class=w> </span><span class=s>&#34;preempted&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>default</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>return</span><span class=w> </span><span class=s>&#34;unkonwn&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>func</span><span class=w> </span><span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nb>len</span><span class=p>(</span><span class=nx>os</span><span class=p>.</span><span class=nx>Args</span><span class=p>)</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=mi>3</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;Usage: %s BINARY SYMBOL\n&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>os</span><span class=p>.</span><span class=nx>Args</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>binPath</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>os</span><span class=p>.</span><span class=nx>Args</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>symbol</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>os</span><span class=p>.</span><span class=nx>Args</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>stopper</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nb>make</span><span class=p>(</span><span class=kd>chan</span><span class=w> </span><span class=nx>os</span><span class=p>.</span><span class=nx>Signal</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>signal</span><span class=p>.</span><span class=nf>Notify</span><span class=p>(</span><span class=nx>stopper</span><span class=p>,</span><span class=w> </span><span class=nx>os</span><span class=p>.</span><span class=nx>Interrupt</span><span class=p>,</span><span class=w> </span><span class=nx>syscall</span><span class=p>.</span><span class=nx>SIGTERM</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// Allow the current process to lock memory for eBPF resources.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>rlimit</span><span class=p>.</span><span class=nf>RemoveMemlock</span><span class=p>();</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// Load pre-compiled programs and maps into the kernel.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>objs</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>bpfObjects</span><span class=p>{}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nf>loadBpfObjects</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>objs</span><span class=p>,</span><span class=w> </span><span class=kc>nil</span><span class=p>);</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>log</span><span class=p>.</span><span class=nf>Fatalf</span><span class=p>(</span><span class=s>&#34;loading objects: %s&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>err</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>defer</span><span class=w> </span><span class=nx>objs</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// Open an ELF binary and read its symbols.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>ex</span><span class=p>,</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>link</span><span class=p>.</span><span class=nf>OpenExecutable</span><span class=p>(</span><span class=nx>binPath</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>log</span><span class=p>.</span><span class=nf>Fatalf</span><span class=p>(</span><span class=s>&#34;opening executable: %s&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>err</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>up</span><span class=p>,</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>ex</span><span class=p>.</span><span class=nf>Uprobe</span><span class=p>(</span><span class=nx>symbol</span><span class=p>,</span><span class=w> </span><span class=nx>objs</span><span class=p>.</span><span class=nx>MonitorSched</span><span class=p>,</span><span class=w> </span><span class=kc>nil</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>log</span><span class=p>.</span><span class=nf>Fatalf</span><span class=p>(</span><span class=s>&#34;creating uretprobe: %s&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>err</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>defer</span><span class=w> </span><span class=nx>up</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// Open a perf event reader from userspace on the PERF_EVENT_ARRAY map</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// described in the eBPF C program.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>rd</span><span class=p>,</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>perf</span><span class=p>.</span><span class=nf>NewReader</span><span class=p>(</span><span class=nx>objs</span><span class=p>.</span><span class=nx>Events</span><span class=p>,</span><span class=w> </span><span class=nx>os</span><span class=p>.</span><span class=nf>Getpagesize</span><span class=p>())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>log</span><span class=p>.</span><span class=nf>Fatalf</span><span class=p>(</span><span class=s>&#34;creating perf event reader: %s&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>err</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>defer</span><span class=w> </span><span class=nx>rd</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>go</span><span class=w> </span><span class=kd>func</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// Wait for a signal and close the perf reader,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// which will interrupt rd.Read() and make the program exit.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=o>&lt;-</span><span class=nx>stopper</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>log</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Received signal, exiting program..&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>if</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>rd</span><span class=p>.</span><span class=nf>Close</span><span class=p>();</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nx>log</span><span class=p>.</span><span class=nf>Fatalf</span><span class=p>(</span><span class=s>&#34;closing perf event reader: %s&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>err</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>log</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;Listening for events..&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// bpfEvent is generated by bpf2go.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=kd>var</span><span class=w> </span><span class=nx>event</span><span class=w> </span><span class=nx>bpfDataT</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%-15s %-20s %-20s\n&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;Goroutine ID&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;Old Status&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;New Status&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>for</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>record</span><span class=p>,</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>rd</span><span class=p>.</span><span class=nf>Read</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>if</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=k>if</span><span class=w> </span><span class=nx>errors</span><span class=p>.</span><span class=nf>Is</span><span class=p>(</span><span class=nx>err</span><span class=p>,</span><span class=w> </span><span class=nx>perf</span><span class=p>.</span><span class=nx>ErrClosed</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>				</span><span class=k>return</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nx>log</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;reading from perf event reader: %s&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>err</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=k>continue</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>if</span><span class=w> </span><span class=nx>record</span><span class=p>.</span><span class=nx>LostSamples</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nx>log</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;perf event ring buffer full, dropped %d samples&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>record</span><span class=p>.</span><span class=nx>LostSamples</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=k>continue</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// Parse the perf event entry into a bpfEvent structure.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>if</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>binary</span><span class=p>.</span><span class=nf>Read</span><span class=p>(</span><span class=nx>bytes</span><span class=p>.</span><span class=nf>NewBuffer</span><span class=p>(</span><span class=nx>record</span><span class=p>.</span><span class=nx>RawSample</span><span class=p>),</span><span class=w> </span><span class=nx>binary</span><span class=p>.</span><span class=nx>LittleEndian</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=nx>event</span><span class=p>);</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nx>log</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;parsing perf event: %s&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>err</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=k>continue</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%-10d %-20s %-20s\n&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>event</span><span class=p>.</span><span class=nx>Goid</span><span class=p>,</span><span class=w> </span><span class=nf>GStatus</span><span class=p>(</span><span class=nx>event</span><span class=p>.</span><span class=nx>OldStatus</span><span class=p>),</span><span class=w> </span><span class=nf>GStatus</span><span class=p>(</span><span class=nx>event</span><span class=p>.</span><span class=nx>NewStatus</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>然后生成ebpf程序和加载程序：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Go data-lang=Go><span class=line><span class=cl><span class=err>$</span><span class=w> </span><span class=k>go</span><span class=w> </span><span class=nx>generate</span><span class=w> </span><span class=c1>// 生成ebpf程序和操作ebpf程序的函数</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=err>$</span><span class=w> </span><span class=k>go</span><span class=w> </span><span class=nx>build</span><span class=w>	</span><span class=c1>// 编译生成加载eBPF的可执行程序</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=err>$</span><span class=w> </span><span class=nx>ls</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nx>bpf_x86_bpfel</span><span class=p>.</span><span class=k>go</span><span class=w>  </span><span class=nx>bpf_x86_bpfel</span><span class=p>.</span><span class=nx>o</span><span class=w>  </span><span class=nx>main</span><span class=p>.</span><span class=k>go</span><span class=w>  </span><span class=nx>uprobe_sched</span><span class=o>*</span><span class=w>  </span><span class=nx>uprobe_sched</span><span class=p>.</span><span class=nx>c</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=err>$</span><span class=w> </span><span class=p>.</span><span class=o>/</span><span class=nx>uprobe_sched</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nx>Usage</span><span class=p>:</span><span class=w> </span><span class=p>.</span><span class=o>/</span><span class=nx>uprobe_sched</span><span class=w> </span><span class=nx>BINARY</span><span class=w> </span><span class=nx>SYMBOL</span><span class=w>
</span></span></span></code></pre></div><p>接下来就找一个Go程序测试一下，随便写一个Go程序到<code>/tmp/test.go</code>中。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Go data-lang=Go><span class=line><span class=cl><span class=c1>// 被观测程序的源码</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kn>package</span><span class=w> </span><span class=nx>main</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kn>import</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=s>&#34;math/rand&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=s>&#34;time&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>func</span><span class=w> </span><span class=nf>task</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>n</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>rand</span><span class=p>.</span><span class=nf>Int</span><span class=p>()</span><span class=w> </span><span class=o>%</span><span class=w> </span><span class=mi>5</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>for</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=p>&lt;</span><span class=w> </span><span class=nx>n</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=o>++</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>t</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>rand</span><span class=p>.</span><span class=nf>Int</span><span class=p>()</span><span class=w> </span><span class=o>%</span><span class=w> </span><span class=mi>10</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nf>Duration</span><span class=p>(</span><span class=nx>t</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=mi>100</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=nb>int</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Millisecond</span><span class=p>)))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>func</span><span class=w> </span><span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>for</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>go</span><span class=w> </span><span class=nf>task</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>创建并编译上述代码。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ cd /tmp
</span></span><span class=line><span class=cl>$ touch test.go
</span></span><span class=line><span class=cl>$ go build test.go
</span></span></code></pre></div><p>接下来就是见证奇迹的时刻了，运行uprobe_sched程序，指定被观测二进制的路径以及要观测的函数，观察输出结果如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ sudo ./uprobe_sched /tmp/test runtime.casgstatus
</span></span><span class=line><span class=cl>2025/11/27 21:01:36 Listening <span class=k>for</span> events..
</span></span><span class=line><span class=cl>Goroutine ID    Old Status           New Status
</span></span><span class=line><span class=cl><span class=m>0</span>          unkonwn              unkonwn
</span></span><span class=line><span class=cl><span class=m>0</span>          unkonwn              idle
</span></span><span class=line><span class=cl><span class=m>14757395258964568840</span> unkonwn              unkonwn
</span></span><span class=line><span class=cl><span class=m>0</span>          unkonwn              idle
</span></span><span class=line><span class=cl><span class=m>14757395258964568840</span> unkonwn              unkonwn
</span></span><span class=line><span class=cl><span class=m>0</span>          unkonwn              idle
</span></span><span class=line><span class=cl><span class=m>14757395258964568840</span> unkonwn              unkonwn
</span></span></code></pre></div><p>貌似这个输出不对，goroutine ID以及状态都不符合预期，这是为什么呢？经过一番折腾，最终找到了原因——eBPF程序获取的参数有问题，<code>runtime.casgstatus</code>函数的三个参数分别在rax，rbx和rcx寄存器中，但是<code>PT_REGS_PARMn(ctx)</code>宏获取到的寄存器分别是rdi，rsi和rdx寄存器。前三个参数分别用rdi，rsi和rdx寄存器传递确实是x86_64的Linux的规范，但问题是Go的runtime不遵守这个规范，所以使用<code>PT_REGS_PARMn(ctx)</code>宏并没有正确获取参数。那怎么知道到底是怎么传递这三个参数的呢？可以对被测试程序的指定函数进行反汇编来确认参数是怎么传递的。以被测试的test程序为例，反汇编命令如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ go tool objdump -S -gnu -s runtime.casgstatus <span class=nb>test</span>
</span></span><span class=line><span class=cl>TEXT runtime.casgstatus<span class=o>(</span>SB<span class=o>)</span> /usr/local/go/src/runtime/proc.go
</span></span><span class=line><span class=cl>func casgstatus<span class=o>(</span>gp *g, oldval, newval uint32<span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  0x4363e0		55			PUSHQ BP                             										// push %rbp
</span></span><span class=line><span class=cl>  0x4363e1		4889e5			MOVQ SP, BP                          								// mov %rsp,%rbp
</span></span><span class=line><span class=cl>  0x4363e4		4883ec40		SUBQ <span class=nv>$0</span>x40, SP                       								// sub <span class=nv>$0</span>x40,%rsp
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=o>(</span>oldval<span class=p>&amp;</span>_Gscan !<span class=o>=</span> 0<span class=o>)</span> <span class=o>||</span> <span class=o>(</span>newval<span class=p>&amp;</span>_Gscan !<span class=o>=</span> 0<span class=o>)</span> <span class=o>||</span> <span class=nv>oldval</span> <span class=o>==</span> newval <span class=o>{</span>
</span></span><span class=line><span class=cl>  0x4363e8		4889442450		MOVQ AX, 0x50<span class=o>(</span>SP<span class=o>)</span>                    							// mov %rax,0x50<span class=o>(</span>%rsp<span class=o>)</span>
</span></span><span class=line><span class=cl>  0x4363ed		895c2458		MOVL BX, 0x58<span class=o>(</span>SP<span class=o>)</span>                    								// mov %ebx,0x58<span class=o>(</span>%rsp<span class=o>)</span>
</span></span><span class=line><span class=cl>  0x4363f1		894c245c		MOVL CX, 0x5c<span class=o>(</span>SP<span class=o>)</span>                    								// mov %ecx,0x5c<span class=o>(</span>%rsp<span class=o>)</span>
</span></span><span class=line><span class=cl>  ......
</span></span></code></pre></div><p>如果对汇编比较熟悉，可以确定三个参数分别是通过rax、rbx和rcx传递的，如果不熟悉也没关系，直接把反汇编结果扔给GPT，让GPT给你答案即可。确定了问题原因，下面把eBPF程序中获取参数的三行代码改成如下。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl>	<span class=c1>// u64 gp   = (u64)PT_REGS_PARM1(ctx);
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// u32 old   = (u64)PT_REGS_PARM2(ctx);
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// u32 new   = (u64)PT_REGS_PARM3(ctx);
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>u64</span> <span class=n>gp</span>  <span class=o>=</span> <span class=p>(</span><span class=n>u64</span><span class=p>)</span><span class=n>ctx</span><span class=o>-&gt;</span><span class=n>rax</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>u32</span> <span class=n>old</span> <span class=o>=</span> <span class=p>(</span><span class=n>u32</span><span class=p>)</span><span class=n>ctx</span><span class=o>-&gt;</span><span class=n>rbx</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>u32</span> <span class=n>new</span> <span class=o>=</span> <span class=p>(</span><span class=n>u32</span><span class=p>)</span><span class=n>ctx</span><span class=o>-&gt;</span><span class=n>rcx</span><span class=p>;</span>
</span></span></code></pre></div><p>再重新生成eBPF程序和加载程序，然后观察，这次没有出现意外，显示正常了。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ go generate
</span></span><span class=line><span class=cl>$ go build
</span></span><span class=line><span class=cl>$ sudo ./uprobe_sched /tmp/test runtime.casgstatus
</span></span><span class=line><span class=cl>2025/11/27 21:18:26 Listening <span class=k>for</span> events..
</span></span><span class=line><span class=cl>Goroutine ID    Old Status           New Status
</span></span><span class=line><span class=cl><span class=m>0</span>          idle                 dead
</span></span><span class=line><span class=cl><span class=m>0</span>          dead                 runnable
</span></span><span class=line><span class=cl><span class=m>1</span>          runnable             running
</span></span><span class=line><span class=cl><span class=m>0</span>          idle                 dead
</span></span><span class=line><span class=cl><span class=m>0</span>          dead                 runnable
</span></span><span class=line><span class=cl><span class=m>0</span>          idle                 dead
</span></span><span class=line><span class=cl><span class=m>2</span>          runnable             running
</span></span><span class=line><span class=cl><span class=m>2</span>          running              waiting
</span></span></code></pre></div><p>PS：在确认了Go的传参规范和Linux的传参规范不一样之后，去搜了一下相关文档，还真的有文档介绍较新版本的Go在amd64架构下的传参<a href=https://go.googlesource.com/go/+/refs/heads/dev.regabi/src/cmd/compile/internal-abi.md#amd64-architecture>约定</a>。对于整形的参数和结果，Go使用一下寄存器进行传递。这个通过反汇编观察到的结论一致。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>RAX, RBX, RCX, RDI, RSI, R8, R9, R10, R11
</span></span></code></pre></div><h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><p>使用cilium/ebpf开发uprobe分为几个部分：</p><ol><li>分析被观测的对象，确定要观测的位置；</li><li>编写eBPF程序，对于观测程序，一般是获取一些环境信息（如参数、返回值等），而不改变被观测对象的环境。获取到的环境信息一般要写入map供用户态程序消费；获取环境信息就需要根据实际情况进行分析，没有绝对统一的方法。</li><li>编写用户态程序，用户态程序负责open、load和attach eBPF程序，并且从map中读出eBPF程序写入的内容并进行处理。</li></ol><p>借助eBPF的开发框架，开发uprobe难度并不大。但是需要注意的是如何获取环境信息，像这里举的例子，获取参数就不能简单的用宏来获取。另外这个例子里要确定goid在g结构体中的偏移，我使用的方法是用dlv动态调试。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ dlv <span class=nb>exec</span> <span class=nb>test</span> // 调试被测程序
</span></span><span class=line><span class=cl>Type <span class=s1>&#39;help&#39;</span> <span class=k>for</span> list of commands.
</span></span><span class=line><span class=cl><span class=o>(</span>dlv<span class=o>)</span> b runtime.casgstatus	// 在观测点设置断点
</span></span><span class=line><span class=cl>Breakpoint <span class=m>1</span> <span class=nb>set</span> at 0x4363e4 <span class=k>for</span> runtime.casgstatus<span class=o>()</span> /usr/local/go/src/runtime/proc.go:1175
</span></span><span class=line><span class=cl><span class=o>(</span>dlv<span class=o>)</span> c	// 运行程序
</span></span><span class=line><span class=cl>&gt; <span class=o>[</span>Breakpoint 1<span class=o>]</span> runtime.casgstatus<span class=o>()</span> /usr/local/go/src/runtime/proc.go:1175 <span class=o>(</span>hits total:1<span class=o>)</span> <span class=o>(</span>PC: 0x4363e4<span class=o>)</span>
</span></span><span class=line><span class=cl>Warning: debugging optimized <span class=k>function</span>
</span></span><span class=line><span class=cl>  1170:	// and casfrom_Gscanstatus instead.
</span></span><span class=line><span class=cl>  1171:	// casgstatus will loop <span class=k>if</span> the g-&gt;atomicstatus is in a Gscan status <span class=k>until</span> the routine that
</span></span><span class=line><span class=cl>  1172:	// put it in the Gscan state is finished.
</span></span><span class=line><span class=cl>  1173:	//
</span></span><span class=line><span class=cl>  1174:	//go:nosplit
</span></span><span class=line><span class=cl><span class=o>=</span>&gt;1175:	func casgstatus<span class=o>(</span>gp *g, oldval, newval uint32<span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  1176:		<span class=k>if</span> <span class=o>(</span>oldval<span class=p>&amp;</span>_Gscan !<span class=o>=</span> 0<span class=o>)</span> <span class=o>||</span> <span class=o>(</span>newval<span class=p>&amp;</span>_Gscan !<span class=o>=</span> 0<span class=o>)</span> <span class=o>||</span> <span class=nv>oldval</span> <span class=o>==</span> newval <span class=o>{</span>
</span></span><span class=line><span class=cl>  1177:			systemstack<span class=o>(</span>func<span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  1178:				// Call on the systemstack to prevent print and throw from counting
</span></span><span class=line><span class=cl>  1179:				// against the nosplit stack reservation.
</span></span><span class=line><span class=cl>  1180:				print<span class=o>(</span><span class=s2>&#34;runtime: casgstatus: oldval=&#34;</span>, hex<span class=o>(</span>oldval<span class=o>)</span>, <span class=s2>&#34; newval=&#34;</span>, hex<span class=o>(</span>newval<span class=o>)</span>, <span class=s2>&#34;\n&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl><span class=o>(</span>dlv<span class=o>)</span> args	// 查看参数信息
</span></span><span class=line><span class=cl><span class=nv>gp</span> <span class=o>=</span> <span class=o>(</span>*runtime.g<span class=o>)(</span>0xc0000061c0<span class=o>)</span>	// 这里是g结构体的起始地址
</span></span><span class=line><span class=cl><span class=nv>oldval</span> <span class=o>=</span> <span class=m>0</span>
</span></span><span class=line><span class=cl><span class=nv>newval</span> <span class=o>=</span> <span class=m>6</span>
</span></span><span class=line><span class=cl><span class=o>(</span>dlv<span class=o>)</span> p <span class=p>&amp;</span>gp.goid
</span></span><span class=line><span class=cl><span class=o>(</span>*uint64<span class=o>)(</span>0xc000006260<span class=o>)</span>	// 这里是g结构体中goid成员的地址，所以goid在g中的偏移量是 0xc000006260 - <span class=nv>0xc0000061c0</span> <span class=o>=</span> 0xa0
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://rand0m42195.github.io/tags/go/>Go</a></li><li><a href=https://rand0m42195.github.io/tags/ebpf/>EBPF</a></li><li><a href=https://rand0m42195.github.io/tags/c/>C</a></li></ul><nav class=paginav><a class=next href=https://rand0m42195.github.io/posts/go-channel/><span class=title>下一页 »</span><br><span>Go Channel源码解读</span></a></nav></footer><div id=comments><script src=https://giscus.app/client.js data-repo=rand0m42195/rand0m42195.github.io data-repo-id=R_kgDOPzDcOw data-category=Announcements data-category-id=DIC_kwDOPzDcO84CvpUm data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=en crossorigin=anonymous async></script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://rand0m42195.github.io/>rand0m's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>